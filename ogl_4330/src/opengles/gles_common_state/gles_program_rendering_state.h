/*
 * This confidential and proprietary software may be used only as
 * authorised by a licensing agreement from ARM Limited
 * (C) COPYRIGHT 2007-2012 ARM Limited
 * ALL RIGHTS RESERVED
 * The entire notice above must be reproduced on all authorised
 * copies and copies may only be made to the extent permitted
 * by a licensing agreement from ARM Limited.
 */

/**
 * @file gles_program_rendering_state.h
 * @brief A program rendering state contains the state required by a program to render.
 */
#ifndef GLES_PROGRAM_RENDERING_STATE_H
#define GLES_PROGRAM_RENDERING_STATE_H

#include "gles_base.h"
#include "gles_config.h"
#include "gles_util.h"
#include <shared/binary_shader/bs_object.h>
#include <shared/binary_shader/bs_symbol.h>

/* forward declaration */
struct gles_fb_program_rendering_state;
struct gles_gb_program_rendering_state;

/* The gles program rendering state contains all the rendering states and stuff that will prevail even after the
 * program object is dead, falsely relinked or modified beyond comparison. Each program object has exactly one
 * program rendering state, always, and the rendering state of the active program (set through glUseprogram)
 * is also stored in the gles2 state, directly.
 *
 * This struct contains the bare minimum of what is required to render an image through our hardware.
 * At the core, this means the bs_program struct, but also some of the gles-only states has to be present to support
 * a few function calls. The uniform array must be present to support glUniform*, the attribute remap table must be
 * present to support glVertex* and all the cached uniform locations must be stored here as well to support the backends.
 *
 * A Program rendering state is also generated by the gles1 shader generator. Even though GLES1 doesn't have any notion of
 * programs, one of these are always active "under the hood".
 */
typedef struct gles_program_rendering_state
{

    /* binary state - contents are initially nilled, and there will be NULL-pointers all around. Once the
	 * linked flag is set, all members in this struct contain data. If this rendering state struct is the
	 * active rendering struct, the linked flag is always set.
	 *
	 * Let me reiterate that because it is such a big deal. THE ACTIVE PROGRAM RENDERING STATE IS ALWAYS LINKED
	 * or NULL in case we have bound gles2 program 0.
	 *
	 * As such, this member is not a pointer, it unconditionally exist, and someone has at least attempted to link it.
	 *
	 * If the linked flag is not set, the link process failed. Some members of the binary struct may still contain data. This
	 * is to adhere to the GLES spec regarding active uniforms and attributes after a failed link.
	 **/
    bs_program binary;

	/**
	 * Storing the bytes required to generate this PRS again. 
	 * Used by the glGetProgramBinary extension. 
	 */
	void* get_program_binary_data;
	u32 get_program_binary_size;

    /* a table that remaps attribute locations to hardware streams. Contents only valid after linking.
	 * Used by all glVertex* calls to reach the proper HW data stream. Since the glVertex* calls always
	 * work on the active rendering state, not the active program, this array is placed here in order to
	 * allow setting of attributes even after the program object is falsely relinked
	 *
	 * GLES2 will set this one up based on aliasing requirements by glBindAttribLocation
	 * GLES1 will set this one up based on the needs of the shader generator.
	 * */
    int attribute_remap_table[GLES_VERTEX_ATTRIB_COUNT];                /* GL location -> GP stream */
    int reverse_attribute_remap_table[MALIGP2_MAX_VS_INPUT_REGISTERS];  /* GP stream -> GL location */

    /* The Uniform Location Array contains all GL-locations used by the API to name uniforms. After a
	 * successful link, this array is build, based on the uniform symbol table. This array is used
	 * by glUniform* and GetUniformLocation. glUniform*, like glVertex* uses the current program state,
	 * not the current program object, and thus this array is placed here in order to allow setting of
	 * uniforms even after the program object is falsely relinked.
	 *
	 * GLES1 does not use this member, and will leave both members blank.
	 **/
    struct bs_uniform_location* gl_uniform_locations; /**< Array of all OpenGL Locations (not to confuse with constant register cell locations) */
    u32 gl_uniform_location_size;                 /**< Size of this array */


    /* These are Uniforms with special gl meanings. Values are uniform array cell or -1 if not present. Not related to gl locations.
     * Public symbols are readable from within the shader; private symbols are not - but will be used for other purposes
     * Private symbols have been flagged with the "mali" tag in its name.
     * If present, these symbols must be set by the backends to their respective values prior to setting up any draw calls */
    s32 viewport_uniform_vs_location;              /**< gl_mali_ViewportTransform - The viewport. A vec4[2] medp symbol, containing scale and transform. */
	s32 pointsize_parameters_uniform_vs_location;  /**< gl_mali_PointSizeScale - The point size scaling to use with AA. An int medp symbol. */
	s32 derivativescale_uniform_fs_location;       /**< gl_mali_DerivativeScale - A vec2 Used to support correct behavior of dFdx, dFdy and fwidth operations*/
	s32 pointcoordscalebias_uniform_fs_location;   /**< gl_mali_PointCoordScaleBias - Used to support point sprite rendering to textures. Must be set to enable use of gl_PointCoord */
	s32 depthrange_uniform_vs_location_near;       /**< gl_DepthRange.near (vs location). A struct member of type highp float members */
    s32 depthrange_uniform_vs_location_far;        /**< gl_DepthRange.far (vs location). A struct member of type highp float members */
    s32 depthrange_uniform_vs_location_diff;       /**< gl_DepthRange.diff (vs location). A struct member of type highp float members */
    s32 depthrange_uniform_fs_location_near;       /**< gl_DepthRange.near (fs location). A struct member of type highp float members */
    s32 depthrange_uniform_fs_location_far;        /**< gl_DepthRange.far (fs location).  A struct member of type highp float members */
    s32 depthrange_uniform_fs_location_diff;       /**< gl_DepthRange.diff (fs location). A struct member of type highp float members */
	s32 fragcoordscale_uniform_fs_location;        /**< gl_mali_FragCoordScale - a vec3 medp sumbol containing xscale, yscale, zscale; used in supersampling configs */

	mali_bool depthrange_locations_fs_in_use;      /**< TRUE if any of the depth range fs locations are valid */
	mali_bool flip_scale_bias_locations_fs_in_use; /**< TRUE if any of the flip/scale/bias fs locations are valid */

	struct gles_fb_program_rendering_state* fb_prs; /* FB specific part of the program rendering state */
	struct gles_gb_program_rendering_state* gb_prs; /* GB specific part of the program rendering state */

	gles_fp16* fp16_cached_fs_uniforms; /** 16-bit fp cache of fragment shader uniforms */

	/* ref count, to ensure object isn't deleted too early */
	mali_atomic_int ref_count;
       /* number of constant (read only) ufiforms in gles1 vertex shader */
	u32 const_regs_to_load;


	/* tracks the frame this PRS was last addref'ed to. This way we can prevent adding it to several frames */
	mali_base_frame_id last_frame_used;
	
} gles_program_rendering_state;

/************************ FUNCTIONS **************************/

/**
 * @brief Allocate a new program rendering state, setting it ready for linking.
 * @return A newly allocated program rendering state with all members nil'ed.
 */
gles_program_rendering_state* _gles_program_rendering_state_alloc(void);

/**
 * @brief Increments reference count for a texture rendering state.
 * @param prs The pointer to the program rendering state we want to reference.
 * @note This operation is supposed to be atomic and thus require no lock
 */
MALI_STATIC_INLINE void _gles_program_rendering_state_addref( gles_program_rendering_state *prs )
{
	MALI_DEBUG_ASSERT_POINTER( prs );
	MALI_DEBUG_ASSERT(_mali_sys_atomic_get( &prs->ref_count ) > 0, ("invalid ref count (%d)", _mali_sys_atomic_get( &prs->ref_count )));
	_mali_sys_atomic_inc( &prs->ref_count );
}

/**
 * @brief Decrement reference count for a program rendering state, and delete the object if zero.
 * @param prs The pointer to the program rendering state we want to dereference.
 * @note This operation is supposed to be atomic and thus require no lock
 */
void _gles_program_rendering_state_deref(gles_program_rendering_state *prs);

#endif

