/* -*- mode: c -*- */

/*
 Pieces for OpenGL ES 1.X vertex shader generation
 */


/* 
   This file is written in an ESSL dialect for piece generation. The following restrictions apply:
   * No reading of vertex varyings
   * No non-constant indexing of vertex varyings
   * No global variables with initializers
   * No function calls
   * You're responsible for perspective division and viewport mapping

   The function names have special meaning and are parsed by the piece generator
 */

#pragma allow_gl_names
#pragma disable_vertex_shader_output_rewrites

#extension GL_ARM_grouped_uniforms : require

#define MAX_TEXTURE_STAGES 8
#define MAX_LIGHTS 8
#define MAX_SKINNING_MATRICES 32

/* transformation */
attribute vec4 attr_Position;
attribute vec3 attr_Normal;

uniform __groupARM(lighting) mat3 NormalMatrix;
uniform __groupARM(basic) mat4 ModelView;
uniform __groupARM(basic) mat4 ModelViewProjViewport;
uniform __groupARM(zkinning) mat4 ProjViewport;
uniform __groupARM(basic) vec4 gl_mali_ViewportTransform[2];

vec4 EyeSpacePosition;
vec3 EyeSpaceNormal;


/* skinning */
attribute vec4 attr_SkinningIndices;
attribute vec4 attr_SkinningWeights;

uniform __groupARM(basic) int NumBones;
uniform __groupARM(zkinning) mat4 SkinningMatrices[MAX_SKINNING_MATRICES];
uniform __groupARM(basic) vec4 ClipPlaneCoefficients;


/* texture coordinate stuff */
attribute vec4 attr_TexCoord0;
attribute vec4 attr_TexCoord1;
attribute vec4 attr_TexCoord2;
attribute vec4 attr_TexCoord3;
attribute vec4 attr_TexCoord4;
attribute vec4 attr_TexCoord5;
attribute vec4 attr_TexCoord6;
attribute vec4 attr_TexCoord7;

uniform __groupARM(basic) int NumTextureMatrices;
uniform __groupARM(textrans) mat4 TextureMatrices[MAX_TEXTURE_STAGES];

vec4 TransformedTexCoords[MAX_TEXTURE_STAGES];

varying vec4 var_TexCoord0;
varying vec4 var_TexCoord1;
varying vec4 var_TexCoord2;
varying vec4 var_TexCoord3;
varying vec4 var_TexCoord4;
varying vec4 var_TexCoord5;
varying vec4 var_TexCoord6;
varying vec4 var_TexCoord7;


/* point size */
attribute float attr_PointSize;

uniform __groupARM(basic) vec4 gl_mali_PointSizeParameters;
uniform __groupARM(basic) vec3 PointSizeAttenuationCoefs;


/* coloring */

attribute vec4 attr_PrimaryColor;

varying mediump vec4 var_PrimaryColor;
varying mediump vec4 var_PrimaryColorTwosided[2];


/* lighting state */
uniform __groupARM(basic) float MaterialDiffuseAlpha;
uniform __groupARM(basic) vec3 MaterialEmissive;
uniform __groupARM(lighting) float MaterialSpecularExponent;

uniform __groupARM(basic) vec3 SceneAmbient;
uniform __groupARM(basic) vec3 SceneColor; /* must be equal to MaterialEmissive + MaterialAmbient * SceneAmbient */

uniform __groupARM(lighting) vec3 LightAmbient[MAX_LIGHTS];
uniform __groupARM(lighting) vec3 LightDiffuse[MAX_LIGHTS];
uniform __groupARM(lighting) vec3 LightSpecular[MAX_LIGHTS];
uniform __groupARM(lighting) vec4 LightPosition[MAX_LIGHTS];
uniform __groupARM(lighting) vec3 LightSpotDirection[MAX_LIGHTS];
uniform __groupARM(lighting) float LightSpotExponent[MAX_LIGHTS];
uniform __groupARM(lighting) float LightSpotCosCutoffAngle[MAX_LIGHTS];
uniform __groupARM(lighting) vec3 LightAttenuation[MAX_LIGHTS];
uniform __groupARM(lighting) int NumLights;

/* misc */
uniform __groupARM(basic) float FogFactor;
uniform __groupARM(basic) float FogAdd;
varying mediump float var_FogDist;
varying mediump float var_ClipPlaneSignedDist;


void transform__skinning_off__eyespacepos_off__eyespacenormal_all__normalize_all()
{
	vec4 viewport_pos = ModelViewProjViewport * attr_Position;
	float invw = clamp(1.0/viewport_pos.w, -1e10, +1e10);
	gl_Position = vec4(viewport_pos.xyz * invw + gl_mali_ViewportTransform[1].xyz, invw);
}

void transform__skinning_off__eyespacepos_on__eyespacenormal_off__normalize_all()
{
	EyeSpacePosition = ModelView * attr_Position;
	vec4 viewport_pos = ModelViewProjViewport * attr_Position;
	float invw = clamp(1.0/viewport_pos.w, -1e10, +1e10);
	gl_Position = vec4(viewport_pos.xyz * invw + gl_mali_ViewportTransform[1].xyz, invw);
}

void transform__skinning_off__eyespacepos_on__eyespacenormal_on__normalize_off()
{
	EyeSpacePosition = ModelView * attr_Position;
	EyeSpaceNormal = NormalMatrix * attr_Normal;
	vec4 viewport_pos = ModelViewProjViewport * attr_Position;
	float invw = clamp(1.0/viewport_pos.w, -1e10, +1e10);
	gl_Position = vec4(viewport_pos.xyz * invw + gl_mali_ViewportTransform[1].xyz, invw);
}

void transform__skinning_off__eyespacepos_on__eyespacenormal_on__normalize_normalize()
{
	EyeSpacePosition = ModelView * attr_Position;
	EyeSpaceNormal = normalize(NormalMatrix * attr_Normal);
	vec4 viewport_pos = ModelViewProjViewport * attr_Position;
	float invw = clamp(1.0/viewport_pos.w, -1e10, +1e10);
	gl_Position = vec4(viewport_pos.xyz * invw + gl_mali_ViewportTransform[1].xyz, invw);
}


void transform__skinning_on__eyespacepos_all__eyespacenormal_off__normalize_all()
{
	mat4 mv = mat4(0.0);
	vec2 iva[4];
	vec2 iv = vec2(attr_SkinningIndices.x, attr_SkinningWeights.x);
	iva[0] = vec2(attr_SkinningIndices.y, attr_SkinningWeights.y);
	iva[1] = vec2(attr_SkinningIndices.z, attr_SkinningWeights.z);
	iva[2] = vec2(attr_SkinningIndices.w, attr_SkinningWeights.w);
	int i = 0;
	do {
		mv += iv.y * SkinningMatrices[int(floor(iv.x))];

		iv = iva[i];
		i++;
	} while (i < NumBones);


	EyeSpacePosition = mv * attr_Position;
	vec4 viewport_pos = ProjViewport * EyeSpacePosition;
	float invw = clamp(1.0/viewport_pos.w, -1e10, +1e10);
	gl_Position = vec4(viewport_pos.xyz * invw + gl_mali_ViewportTransform[1].xyz, invw);
}

void transform__skinning_on__eyespacepos_all__eyespacenormal_on__normalize_normalize()
{
	mat4 mv = mat4(0.0);
	vec2 iva[4];
	vec2 iv = vec2(attr_SkinningIndices.x, attr_SkinningWeights.x);
	iva[0] = vec2(attr_SkinningIndices.y, attr_SkinningWeights.y);
	iva[1] = vec2(attr_SkinningIndices.z, attr_SkinningWeights.z);
	iva[2] = vec2(attr_SkinningIndices.w, attr_SkinningWeights.w);
	int i = 0;
	do {
		mv += iv.y * SkinningMatrices[int(floor(iv.x))];

		iv = iva[i];
		i++;
	} while (i < NumBones);


	/* Dynamic normal transformation algorithm as described in
	   https://inside.trondheim.arm.com/wiki/index.php/Normal_Transform_for_Matrix_Palette_Skinning
	*/
	vec3 mvt0 = vec3(mv[0][0], mv[1][0], mv[2][0]);
	vec3 mvt1 = vec3(mv[0][1], mv[1][1], mv[2][1]);
	vec3 mvt2 = vec3(mv[0][2], mv[1][2], mv[2][2]);

	vec3 cpd1 = cross(mvt2, attr_Normal);
	vec3 cpd2 = cross(mvt0, mvt1);
	vec3 normal = vec3(dot(mvt1, cpd1), -dot(mvt0, cpd1), dot(cpd2, attr_Normal));

	EyeSpaceNormal = normalize(normal);


	EyeSpacePosition = mv * attr_Position;
	vec4 viewport_pos = ProjViewport * EyeSpacePosition;
	float invw = clamp(1.0/viewport_pos.w, -1e10, +1e10);
	gl_Position = vec4(viewport_pos.xyz * invw + gl_mali_ViewportTransform[1].xyz, invw);
}

void transform__skinning_on__eyespacepos_all__eyespacenormal_on__normalize_off()
{
	mat4 mv = mat4(0.0);
	vec2 iva[4];
	vec2 iv = vec2(attr_SkinningIndices.x, attr_SkinningWeights.x);
	iva[0] = vec2(attr_SkinningIndices.y, attr_SkinningWeights.y);
	iva[1] = vec2(attr_SkinningIndices.z, attr_SkinningWeights.z);
	iva[2] = vec2(attr_SkinningIndices.w, attr_SkinningWeights.w);
	int i = 0;
	do {
		mv += iv.y * SkinningMatrices[int(floor(iv.x))];

		iv = iva[i];
		i++;
	} while (i < NumBones);


	/* Dynamic normal transformation algorithm as described in
	   https://inside.trondheim.arm.com/wiki/index.php/Normal_Transform_for_Matrix_Palette_Skinning
	*/
	vec3 mvt0 = vec3(mv[0][0], mv[1][0], mv[2][0]);
	vec3 mvt1 = vec3(mv[0][1], mv[1][1], mv[2][1]);
	vec3 mvt2 = vec3(mv[0][2], mv[1][2], mv[2][2]);

	vec3 cpd1 = cross(mvt2, attr_Normal);
	vec3 cpd2 = cross(mvt0, mvt1);
	vec3 normal = vec3(dot(mvt1, cpd1), -dot(mvt0, cpd1), dot(cpd2, attr_Normal));

	EyeSpaceNormal = normal / dot(mvt2, cpd2);


	EyeSpacePosition = mv * attr_Position;
	vec4 viewport_pos = ProjViewport * EyeSpacePosition;
	float invw = clamp(1.0/viewport_pos.w, -1e10, +1e10);
	gl_Position = vec4(viewport_pos.xyz * invw + gl_mali_ViewportTransform[1].xyz, invw);
}


#define LIGHT_DIR_CODE(LightPos) vec3 NormalizedLightDir; float dist; { float lwnzero = LightPos.w; vec3 ScaledLightDir = LightPos.xyz - float(lwnzero)*EyeSpacePosition.xyz/EyeSpacePosition.w; NormalizedLightDir = normalize(ScaledLightDir); dist = length(ScaledLightDir); }

//common case code, not general enough
//#define LIGHT_DIR_CODE(LightPos) vec3 NormalizedLightDir; vec3 LightDir; { LightDir = EyeSpacePosition.xyz + 0.0*LightPos.xyz; NormalizedLightDir = normalize(LightDir); }
#define HALF_VEC_CODE vec3 HalfVec = normalize(vec3(NormalizedLightDir.xy, NormalizedLightDir.z + 1.0))
#define DIFFUSE_DOT_CODE(Normal) float DiffuseDot = max(dot(Normal, NormalizedLightDir), 0.0)

//#define ATTENUATION_CODE(idx) float dist = length(LightDir); float attenuation = inversesqrt(LightAttenuation[idx].x + LightAttenuation[idx].y*dist + LightAttenuation[idx].z*(dist*dist))
//this also handles pos.w == 0.0, but crosses the 256 instruction limit in several shaders
#define ATTENUATION_CODE(idx) float attenuation = 1.0 / (LightAttenuation[idx].x + LightAttenuation[idx].y*dist + LightAttenuation[idx].z*(dist*dist))

#define SPOTLIGHT_CODE(idx) float spot_coef = max(dot(-NormalizedLightDir, LightSpotDirection[idx]), 0.0); float spotlight = 1.0; if(LightSpotCosCutoffAngle[idx] > -1.0) { spotlight = float(spot_coef >= LightSpotCosCutoffAngle[idx]) * pow(spot_coef, LightSpotExponent[idx]); }
#define PER_LIGHT_CODE(idx, Normal) LIGHT_DIR_CODE(LightPosition[idx]); HALF_VEC_CODE; DIFFUSE_DOT_CODE(Normal)
#define LIGHT_FOOTER(alpha) var_PrimaryColor = vec4(clamp(LightColor, 0.0, 1.0), (alpha))
#define TWO_LIGHT_FOOTER(alpha) var_PrimaryColorTwosided[0] = vec4(clamp(LightColors[0], 0.0, 1.0), (alpha));  var_PrimaryColorTwosided[1] = vec4(clamp(LightColors[1], 0.0, 1.0), (alpha))

void lighting__numlights_off__twosided_all__spotlight_all__specular_all__attenuation_all__colormaterial_all()
{
	var_PrimaryColor = clamp(attr_PrimaryColor, 0.0, 1.0);
}

void lighting__numlights_zero__twosided_all__spotlight_all__specular_all__attenuation_all__colormaterial_off()
{
	vec3 LightColor = SceneColor;
	LIGHT_FOOTER(MaterialDiffuseAlpha);
}

void lighting__numlights_zero__twosided_all__spotlight_all__specular_all__attenuation_all__colormaterial_ambientdiffuse()
{
	vec3 TrackedColor = attr_PrimaryColor.xyz;
	vec3 LightColor = MaterialEmissive + TrackedColor*SceneAmbient;
	LIGHT_FOOTER(attr_PrimaryColor.w);
}


void lighting__numlights_one__twosided_off__spotlight_off__specular_off__attenuation_off__colormaterial_off()
{
	PER_LIGHT_CODE(0, EyeSpaceNormal);
	vec3 LightColor = SceneColor + LightAmbient[0] + LightDiffuse[0] * DiffuseDot;
	LIGHT_FOOTER(MaterialDiffuseAlpha);
}

void lighting__numlights_one__twosided_off__spotlight_off__specular_off__attenuation_off__colormaterial_ambientdiffuse()
{
	vec3 TrackedColor = attr_PrimaryColor.xyz;
	PER_LIGHT_CODE(0, EyeSpaceNormal);
	vec3 LightColor = MaterialEmissive + TrackedColor * 
		(SceneAmbient + LightAmbient[0] + LightDiffuse[0] * DiffuseDot);
	LIGHT_FOOTER(attr_PrimaryColor.w);
}

void lighting__numlights_one__twosided_off__spotlight_off__specular_on__attenuation_off__colormaterial_off()
{
	PER_LIGHT_CODE(0, EyeSpaceNormal);
	vec3 LightColor = SceneColor + (LightAmbient[0] + LightDiffuse[0] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(EyeSpaceNormal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[0];
	LIGHT_FOOTER(MaterialDiffuseAlpha);
}

void lighting__numlights_one__twosided_off__spotlight_off__specular_on__attenuation_off__colormaterial_ambientdiffuse()
{
	vec3 TrackedColor = attr_PrimaryColor.xyz;
	PER_LIGHT_CODE(0, EyeSpaceNormal);
	vec3 LightColor = MaterialEmissive + TrackedColor * 
		(SceneAmbient + LightAmbient[0] + LightDiffuse[0] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(EyeSpaceNormal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[0];
	LIGHT_FOOTER(attr_PrimaryColor.w);
}

void lighting__numlights_one__twosided_off__spotlight_off__specular_on__attenuation_on__colormaterial_off()
{
	PER_LIGHT_CODE(0, EyeSpaceNormal);
	ATTENUATION_CODE(0);
	vec3 LightColor = SceneColor + attenuation*((LightAmbient[0] + LightDiffuse[0] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(EyeSpaceNormal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[0]);
	LIGHT_FOOTER(MaterialDiffuseAlpha);
}

void lighting__numlights_one__twosided_off__spotlight_off__specular_on__attenuation_on__colormaterial_ambientdiffuse()
{
	vec3 TrackedColor = attr_PrimaryColor.xyz;
	PER_LIGHT_CODE(0, EyeSpaceNormal);
	ATTENUATION_CODE(0);
	vec3 LightColor = MaterialEmissive + TrackedColor * SceneAmbient + attenuation*(TrackedColor * 
												(LightAmbient[0] + LightDiffuse[0] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(EyeSpaceNormal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[0]);
	LIGHT_FOOTER(attr_PrimaryColor.w);
}


vec3 LightColor;
vec3 LightColors[2];
void lighting__numlights_one__numlights_many__twosided_off__spotlight_off__specular_all__attenuation_off__colormaterial_off()
{

	int i = 0;
	LightColor = SceneColor;
	do {
		PER_LIGHT_CODE(i, EyeSpaceNormal);
		LightColor += (LightAmbient[i] + LightDiffuse[i] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(EyeSpaceNormal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[i];
	
		++i;
	} while(i < NumLights);
	LIGHT_FOOTER(MaterialDiffuseAlpha);

}


void lighting__numlights_one__numlights_many__twosided_off__spotlight_off__specular_all__attenuation_off__colormaterial_ambientdiffuse()
{

	vec3 TrackedColor = attr_PrimaryColor.xyz;
	int i = 0;
	LightColor = MaterialEmissive + TrackedColor*SceneAmbient;
	do {
		PER_LIGHT_CODE(i, EyeSpaceNormal);
		LightColor += TrackedColor * 
			(LightAmbient[i] + LightDiffuse[i] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(EyeSpaceNormal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[i];
	
		++i;
	} while(i < NumLights);
	LIGHT_FOOTER(attr_PrimaryColor.w);

}


void lighting__numlights_one__numlights_many__twosided_off__spotlight_off__specular_off__attenuation_all__colormaterial_off()
{
	int i = 0;
	LightColor = SceneColor;
	do {
		PER_LIGHT_CODE(i, EyeSpaceNormal);
		ATTENUATION_CODE(i);
		LightColor += attenuation*
			(LightAmbient[i] + LightDiffuse[i] * DiffuseDot);
		++i;
	} while(i < NumLights);
	LIGHT_FOOTER(MaterialDiffuseAlpha);
}

void lighting__numlights_one__numlights_many__twosided_off__spotlight_on__spotlight_off__specular_all__attenuation_all__colormaterial_off()
{
	int i = 0;
	LightColor = SceneColor;
	do {
		PER_LIGHT_CODE(i, EyeSpaceNormal);
		ATTENUATION_CODE(i);
		SPOTLIGHT_CODE(i);
		LightColor += spotlight*attenuation*(
			(LightAmbient[i] + LightDiffuse[i] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(EyeSpaceNormal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[i]);
		++i;
	} while(i < NumLights);
	LIGHT_FOOTER(MaterialDiffuseAlpha);
}


void lighting__numlights_one__numlights_many__twosided_off__spotlight_on__spotlight_off__specular_on__specular_off__attenuation_on__attenuation_off__colormaterial_ambientdiffuse()
{
	vec3 TrackedColor = attr_PrimaryColor.xyz;
	int i = 0;
	LightColor = MaterialEmissive + TrackedColor*SceneAmbient;
	do {
		PER_LIGHT_CODE(i, EyeSpaceNormal);
		ATTENUATION_CODE(i);
		SPOTLIGHT_CODE(i);
		LightColor += spotlight*attenuation*(TrackedColor * 
											 (LightAmbient[i] + LightDiffuse[i] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(EyeSpaceNormal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[i]);
			
		++i;
	} while(i < NumLights);
	LIGHT_FOOTER(attr_PrimaryColor.w);
}

void lighting__numlights_one__numlights_many__twosided_on__spotlight_on__spotlight_off__specular_all__attenuation_all__colormaterial_off()
{
	int j = 0;
	do {
		vec3 Normal = EyeSpaceNormal * float(2*j - 1);
		LightColors[j] = SceneColor;
		int i = 0;
		do {
			PER_LIGHT_CODE(i, Normal);
			ATTENUATION_CODE(i);
			SPOTLIGHT_CODE(i);
			LightColors[j] += spotlight*attenuation*(
							   (LightAmbient[i] + LightDiffuse[i] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(Normal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[i]);
			
			++i;
		} while(i < NumLights);
		++j;
	} while(j < 2);
	TWO_LIGHT_FOOTER(MaterialDiffuseAlpha);
}

void lighting__numlights_one__numlights_many__twosided_on__spotlight_on__spotlight_off__specular_on__specular_off__attenuation_on__attenuation_off__colormaterial_ambientdiffuse()
{
	vec3 TrackedColor = attr_PrimaryColor.xyz;
	int j = 0;
	do {
		vec3 Normal = EyeSpaceNormal * float(2*j - 1);
		LightColors[j] = MaterialEmissive + TrackedColor*SceneAmbient;
		int i = 0;
		do {
			PER_LIGHT_CODE(i, Normal);
			ATTENUATION_CODE(i);
			SPOTLIGHT_CODE(i);
			LightColors[j] += spotlight*attenuation*(TrackedColor * 
							   (LightAmbient[i] + LightDiffuse[i] * DiffuseDot) + float(DiffuseDot > 0.0) * max(pow(dot(Normal, HalfVec), MaterialSpecularExponent), 0.0) * LightSpecular[i]);
			
			++i;
		} while(i < NumLights);
		++j;
	} while(j < 2);
	TWO_LIGHT_FOOTER(attr_PrimaryColor.w);
}


void texcoordcopy__0() { var_TexCoord0 = attr_TexCoord0; }
void texcoordcopy__1() { var_TexCoord1 = attr_TexCoord1; }
void texcoordcopy__2() { var_TexCoord2 = attr_TexCoord2; }
void texcoordcopy__3() { var_TexCoord3 = attr_TexCoord3; }
void texcoordcopy__4() { var_TexCoord4 = attr_TexCoord4; }
void texcoordcopy__5() { var_TexCoord5 = attr_TexCoord5; }
void texcoordcopy__6() { var_TexCoord6 = attr_TexCoord6; }
void texcoordcopy__7() { var_TexCoord7 = attr_TexCoord7; }

void texcoordread__0() { TransformedTexCoords[0] = attr_TexCoord0; }
void texcoordread__1() { TransformedTexCoords[1] = attr_TexCoord1; }
void texcoordread__2() { TransformedTexCoords[2] = attr_TexCoord2; }
void texcoordread__3() { TransformedTexCoords[3] = attr_TexCoord3; }
void texcoordread__4() { TransformedTexCoords[4] = attr_TexCoord4; }
void texcoordread__5() { TransformedTexCoords[5] = attr_TexCoord5; }
void texcoordread__6() { TransformedTexCoords[6] = attr_TexCoord6; }
void texcoordread__7() { TransformedTexCoords[7] = attr_TexCoord7; }

void texcoordwrite__0() { var_TexCoord0 = TransformedTexCoords[0]; }
void texcoordwrite__1() { var_TexCoord1 = TransformedTexCoords[1]; }
void texcoordwrite__2() { var_TexCoord2 = TransformedTexCoords[2]; }
void texcoordwrite__3() { var_TexCoord3 = TransformedTexCoords[3]; }
void texcoordwrite__4() { var_TexCoord4 = TransformedTexCoords[4]; }
void texcoordwrite__5() { var_TexCoord5 = TransformedTexCoords[5]; }
void texcoordwrite__6() { var_TexCoord6 = TransformedTexCoords[6]; }
void texcoordwrite__7() { var_TexCoord7 = TransformedTexCoords[7]; }

void texcoordtransform() {
	int i = 0;
	do {
		TransformedTexCoords[i] = TextureMatrices[i] * TransformedTexCoords[i];
		i++;
	} while (i < NumTextureMatrices);
}

#define REFLECTION_CODE(output) {output = vec4(reflect(EyeSpacePosition.xyz, EyeSpaceNormal).xyz, 1.0);}

void texgenreflection__0() {REFLECTION_CODE(TransformedTexCoords[0]);}
void texgenreflection__1() {REFLECTION_CODE(TransformedTexCoords[1]);}
void texgenreflection__2() {REFLECTION_CODE(TransformedTexCoords[2]);}
void texgenreflection__3() {REFLECTION_CODE(TransformedTexCoords[3]);}
void texgenreflection__4() {REFLECTION_CODE(TransformedTexCoords[4]);}
void texgenreflection__5() {REFLECTION_CODE(TransformedTexCoords[5]);}
void texgenreflection__6() {REFLECTION_CODE(TransformedTexCoords[6]);}
void texgenreflection__7() {REFLECTION_CODE(TransformedTexCoords[7]);}

#define NORMALMAP_CODE(output) {output = vec4(EyeSpaceNormal, 1.0);}

void texgennormal__0() {NORMALMAP_CODE(TransformedTexCoords[0]);}
void texgennormal__1() {NORMALMAP_CODE(TransformedTexCoords[1]);}
void texgennormal__2() {NORMALMAP_CODE(TransformedTexCoords[2]);}
void texgennormal__3() {NORMALMAP_CODE(TransformedTexCoords[3]);}
void texgennormal__4() {NORMALMAP_CODE(TransformedTexCoords[4]);}
void texgennormal__5() {NORMALMAP_CODE(TransformedTexCoords[5]);}
void texgennormal__6() {NORMALMAP_CODE(TransformedTexCoords[6]);}
void texgennormal__7() {NORMALMAP_CODE(TransformedTexCoords[7]);}

void pointsize__copy_off__attenuation_all() {}

void pointsize__copy_on__attenuation_off() {
	gl_PointSize = clamp(attr_PointSize, gl_mali_PointSizeParameters.x, gl_mali_PointSizeParameters.y) * gl_mali_PointSizeParameters.z;
}

void pointsize__copy_on__attenuation_on() {
	float d = length(EyeSpacePosition.xyz);
	float attenuationScale = inversesqrt(PointSizeAttenuationCoefs.x + PointSizeAttenuationCoefs.y *d + d*d*PointSizeAttenuationCoefs.z);
	gl_PointSize = clamp(attr_PointSize*attenuationScale, gl_mali_PointSizeParameters.x, gl_mali_PointSizeParameters.y) * gl_mali_PointSizeParameters.z;

}


void fog__dist_off() {}

void fog__dist_on() {
	var_FogDist = abs(EyeSpacePosition.z) * FogFactor;
}

void fog__dist_add() {
	var_FogDist = abs(EyeSpacePosition.z) * FogFactor + FogAdd;
}


void clipplane__plane0_off() {}

void clipplane__plane0_on() {
	var_ClipPlaneSignedDist = dot(ClipPlaneCoefficients, EyeSpacePosition);
}
