/*
 * This confidential and proprietary software may be used only as
 * authorised by a licensing agreement from ARM Limited
 * (C) COPYRIGHT 2005, 2007-2012 ARM Limited
 * ALL RIGHTS RESERVED
 * The entire notice above must be reproduced on all authorised
 * copies and copies may only be made to the extent permitted
 * by a licensing agreement from ARM Limited.
 */

#include <mali_system.h>
#include <EGL/mali_egl.h>
#include "egl_main.h"
#include "egl_misc.h"
#include "egl_handle.h"
#include "egl_platform.h"
#if EGL_KHR_lock_surface_ENABLE
#include "egl_lock_surface.h"
#endif
#if EGL_FEATURE_SURFACE_SCALING_ENABLE
#include "egl_ss_entrypoint_name.h"
#include "egl_surface_scaling.h"
#endif

#ifdef HAVE_ANDROID_OS
#if MALI_ANDROID_API >= 15
#include <system/window.h>
#else
#include <ui/egl/android_natives.h>
#include <ui/android_native_buffer.h>
#endif
#include <utils/Log.h>
#include <cutils/properties.h>
#define AERR(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, "[EGL-ERROR]", "%s:%d: " fmt,__func__,__LINE__,args)
#define AINF(fmt, args...) __android_log_print(ANDROID_LOG_INFO, "", "%s:%d: " fmt, MALI_FUNCTION, __LINE__,##args)
#endif

/*nexell add*/
/*
#define CONFIG_GLSE_RGBA32_DISABLE
*/

/* maximum size of a pbuffer is the same as the maximum size of a regular surface */
#define MAX_PBUFFER_WIDTH  MALI200_MAX_TEXTURE_SIZE
#define MAX_PBUFFER_HEIGHT MALI200_MAX_TEXTURE_SIZE
#define MAX_PBUFFER_PIXELS (MAX_PBUFFER_WIDTH * MAX_PBUFFER_HEIGHT)

#define MIN_SWAP_INTERVAL  0
#define MAX_SWAP_INTERVAL 10


/* This is used to fill in the config value for Surface Scaling with a default value
 */
#ifndef EGL_SURFACE_SCALING_NOT_SUPPORTED
#define EGL_SURFACE_SCALING_NOT_SUPPORTED EGL_FALSE
#endif

#if EGL_ANDROID_recordable_ENABLE
#define EGL_ANDROID_RECORDABLE_SUPPORTED EGL_TRUE
#else
#define EGL_ANDROID_RECORDABLE_SUPPORTED EGL_FALSE
#endif

#if EGL_ANDROID_framebuffer_target_ENABLE
#define EGL_ANDROID_FRAMEBUFFER_TARGET_SUPPORTED EGL_TRUE
#else
#define EGL_ANDROID_FRAMEBUFFER_TARGET_SUPPORTED EGL_FALSE
#endif

#define CONFIG_GLES_BITS         EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT

#define CONFIG_GLES_DEPTH_SIZE   24
#define CONFIG_GLES_STENCIL_SIZE  8

enum egl_config_id
{
	CONFIG_ID_DONT_CARE                       = -1,
	CONFIG_ID_VG_RGB_565_1X                   = 2,
	CONFIG_ID_VG_ARGB_4444_1X                 = 10,
	CONFIG_ID_VG_ARGB_8888_1X                 = 6,
	CONFIG_ID_VG_ARGB_8888_16X                = 8,
	CONFIG_ID_VG_XRGB_8888_1X                 = 36,
	CONFIG_ID_VG_PIXMAP_A8_1X                 = 17,

	CONFIG_ID_GLES                            = 5,
	CONFIG_ID_GLES_4X                         = 3,
	CONFIG_ID_GLES_16X                        = 4,

	CONFIG_ID_GLES_RGBA32                     = 9,
	CONFIG_ID_GLES_RGBX32                     = 38,
	CONFIG_ID_GLES_RGBA32_4X                  = 12,
	CONFIG_ID_GLES_RGBA32_16X                 = 15,
	CONFIG_ID_GLES_ARGB_1555                  = 19,
	CONFIG_ID_GLES_ARGB_1555_4X               = 18,
	CONFIG_ID_GLES_ARGB_1555_16X              = 20,

	CONFIG_ID_GLES_ARGB_4444                  = 21,
	CONFIG_ID_GLES_ARGB_4444_4X               = 22,
	CONFIG_ID_GLES_ARGB_4444_16X              = 23,

	CONFIG_ID_VG_AND_GLES_ARGB_8888_4X        = 7,
	CONFIG_ID_VG_AND_GLES_RGB_565_4X          = 11,
	CONFIG_ID_VG_AND_GLES_XRGB_8888_4X        = 37,

	CONFIG_ID_PIXMAP_L8                       = 13,
	CONFIG_ID_PIXMAP_AL8                      = 14,

#if EGL_KHR_lock_surface_ENABLE
	/* These configs are for software rendering only, no client API support */
	CONFIG_ID_LS_ARGB_8888                    = 27,
	CONFIG_ID_LS_RGB_565                      = 28,
	CONFIG_ID_LS_BGRA_8888                    = 34,
	CONFIG_ID_LS_ARGB_1555                    = 35,

#if EGL_KHR_pixmap_lock_surface_ENABLE
	CONFIG_ID_LS_GLES_8888                    = 39,
#endif
#endif

#ifdef EGL_EXTENDED_CONFIGS
	CONFIG_ID_GLES_565_ZERO_DEPTH             = 29,
	CONFIG_ID_GLES_8888_ZERO_DEPTH            = 30,
	CONFIG_ID_GLES_8880_ZERO_DEPTH            = 31,
	CONFIG_ID_GLES_8880                       = 32,/* depth 24, stencil 8 */
#endif

#ifdef HAVE_ANDROID_OS
	CONFIG_ID_GLES_8888_BGRA32                = 33,
#if EGL_ANDROID_recordable_ENABLE
	CONFIG_ID_RECORDABLE_YV12                 = 40,
#endif
#endif
};

/* This is needed when sorting the configurations.
 * Since quicksort does not take any additional parameters,
 * we have to temporarily store the display handle when doing
 * the sorting. This is threadsafe by protection of mutex
 */
MALI_STATIC EGLDisplay __egl_config_display = EGL_NO_DISPLAY;
MALI_STATIC EGLint __egl_config_color_components = 0;

#if 1 /* org */
#define RENDER_METHOD_DIRECT_MODE RENDER_METHOD_DIRECT_RENDERING
#else /* nexell temp test */
#define RENDER_METHOD_DIRECT_MODE RENDER_METHOD_BUFFER_BLIT
#endif

/**
 * List of valid configurations
 */
MALI_STATIC egl_config __egl_configs_default_display[] = {
#ifdef EGL_MALI_VG
	/* OpenVG sRGBA 4444 1x config */
	{
		16, 4, 4, 4, 0, 4, 8,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_VG_ARGB_4444_1X, EGL_OPENVG_BIT, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		EGL_OPENVG_BIT, 0, 0, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A4R4G4B4, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenVG sRGBA 8888 1x config */
	{
		32, 8, 8, 8, 0, 8, 8,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_VG_ARGB_8888_1X, EGL_OPENVG_BIT, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		EGL_OPENVG_BIT, 0, 0, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenVG sRGBX 8888 1x config */
	{
		32, 8, 8, 8, 0, 0, 8,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_VG_XRGB_8888_1X, EGL_OPENVG_BIT, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		EGL_OPENVG_BIT, 0, 0, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED,
		EGL_FALSE, EGL_FALSE
	},
	/* OpenVG sRGBA 8888 16x config, nonconformant */
	{
		32, 8, 8, 8, 0, 8, 8,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_VG_ARGB_8888_16X, 0, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		EGL_OPENVG_BIT, 1, 16, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* Pixmap A8 */
	{
		8, 0, 0, 0, 0, 8, 0,  /* buffer size, red, blue, green, lum, alpha, alpha mask */
		EGL_FALSE, EGL_FALSE, EGL_LUMINANCE_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_VG_PIXMAP_A8_1X, 0, 0, 0,
		0, 0, 0, 0, 0, EGL_TRUE, 0, 0,
		0, 0, 0, 0,
		EGL_PIXMAP_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenVG sRGBX 5650 1x config */
	{
		16, 5, 6, 5, 0, 0, 8,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_VG_RGB_565_1X, EGL_OPENVG_BIT, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		EGL_OPENVG_BIT, 0, 0, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_R5G6B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
#endif /* EGL_MALI_VG */

#ifdef EGL_MALI_GLES
	/* OpenGL ES 565 1x */
	{
		16, 5, 6, 5, 0, 0, 0,
		EGL_TRUE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_R5G6B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_ANDROID_RECORDABLE_SUPPORTED, EGL_FALSE
	},
	/* OpenGL ES 565 4x */
	{
		16, 5, 6, 5, 0, 0, 0,
		EGL_TRUE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_4X, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 1, 4, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_R5G6B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_ANDROID_RECORDABLE_SUPPORTED, EGL_FALSE
	},
	/* OpenGL ES 565 16x */
	{
		16, 5, 6, 5, 0, 0, 0,
		EGL_TRUE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_GLES_16X, 0, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 1, 16, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_R5G6B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_ANDROID_RECORDABLE_SUPPORTED, EGL_FALSE
	},
	/* OpenGL ES 1555 1x */
	{
		16, 5, 5, 5, 0, 1, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_ARGB_1555, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A1R5G5B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenGL ES 1555 4x */
	{
		16, 5, 5, 5, 0, 1, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_ARGB_1555_4X, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 1, 4, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A1R5G5B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenGL ES 1555 16x */
	{
		16, 5, 5, 5, 0, 1, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_GLES_ARGB_1555_16X, 0, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 1, 16, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A1R5G5B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenGL ES 4444 1x */
	{
		16, 4, 4, 4, 0, 4, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_ARGB_4444, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A4R4G4B4, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenGL ES 4444 4x */
	{
		16, 4, 4, 4, 0, 4, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_ARGB_4444_4X, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 1, 4, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A4R4G4B4, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenGL ES 4444 16x */
	{
		16, 4, 4, 4, 0, 4, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_GLES_ARGB_4444_16X, 0, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 1, 16, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A4R4G4B4, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	#ifndef CONFIG_GLSE_RGBA32_DISABLE
	/* OpenGL ES 8888 1x */
	{
		32, 8, 8, 8, 0, 8, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_RGBA32, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_ANDROID_RECORDABLE_SUPPORTED, EGL_FALSE,
	},
	/* OpenGL ES 8880 1x */
	{
		32, 8, 8, 8, 0, 0, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_GLES_RGBX32, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED,
		EGL_FALSE, EGL_FALSE
	},
	/* OpenGL ES 8888 4x */
	{
		32, 8, 8, 8, 0, 8, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_RGBA32_4X, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 1, 4, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_ANDROID_RECORDABLE_SUPPORTED, EGL_FALSE
	},
	/* OpenGL ES 8888 16x */
	{
		32, 8, 8, 8, 0, 8, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_GLES_RGBA32_16X, 0, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 1, 16, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED,
		EGL_ANDROID_RECORDABLE_SUPPORTED, EGL_FALSE 
	},
	#endif
	/* Configs usable by native pixmaps only (and indirectly by EGLImages) */
	/* Pixmap L8 */
	{
		#if 0 /* org */
		8, 0, 0, 0, 8, 0, 0,  /* buffer size, red, blue, green, lum, alpha, alpha mask */
		EGL_FALSE, EGL_FALSE, EGL_LUMINANCE_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_PIXMAP_L8, 0, 0, 0,
		0, 0, 0, 0, 0, EGL_TRUE, 0, 0,
		0, 0, 0, 0,
		EGL_PIXMAP_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
		#else /* added by nexell */
		8, 0, 0, 0, 8, 0, 0,  /* buffer size, red, blue, green, lum, alpha, alpha mask */
		EGL_FALSE, EGL_FALSE, EGL_LUMINANCE_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_PIXMAP_L8, 0, 0, 0,
		0, 0, 0, 0, 0, EGL_TRUE, 0, 0,
		EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT, 0, 0, 0,
		EGL_PIXMAP_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
		#endif
	},
	/* Pixmap AL8 */
	{
		#if 0 /* org */
		16, 0, 0, 0, 8, 8, 0,  /* buffer size, red, blue, green, lum, alpha, alpha mask */
		EGL_FALSE, EGL_FALSE, EGL_LUMINANCE_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_PIXMAP_AL8, 0, 0, 0,
		0, 0, 0, 0, 0, EGL_TRUE, 0, 0,
		0, 0, 0, 0,
		EGL_PIXMAP_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
		#else /* added by nexell */
		16, 0, 0, 0, 8, 8, 0,  /* buffer size, red, blue, green, lum, alpha, alpha mask */
		EGL_FALSE, EGL_FALSE, EGL_LUMINANCE_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_PIXMAP_AL8, 0, 0, 0,
		0, 0, 0, 0, 0, EGL_TRUE, 0, 0,
		EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT, 0, 0, 0,
		EGL_PIXMAP_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
		#endif
	},
#endif /* EGL_MALI_GLES */

#if defined(EGL_MALI_GLES) && defined(EGL_MALI_VG)
	#ifndef CONFIG_GLSE_RGBA32_DISABLE
	/* Combined OpenVG and OpenGL ES 8888 4x */
	{
		32, 8, 8, 8, 0, 8, 8,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_VG_AND_GLES_ARGB_8888_4X, EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT | EGL_OPENVG_BIT, 1, 4, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	#endif
	/* Combined OpenVG and OpenGL ES 565 4x */
	{
		16, 5, 6, 5, 0, 0, 6,
		EGL_TRUE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_VG_AND_GLES_RGB_565_4X, EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT | EGL_OPENVG_BIT, 1, 4, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_R5G6B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	#ifndef CONFIG_GLSE_RGBA32_DISABLE
	/* Combined OpenVG and OpenGL ES 8880 4x */
	{
		32, 8, 8, 8, 0, 0, 8,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NON_CONFORMANT_CONFIG, CONFIG_ID_VG_AND_GLES_XRGB_8888_4X, EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT | EGL_OPENVG_BIT, 1, 4, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	#endif
#endif /* EGL_MALI_GLES and EGL_MALI_VG */
#if EGL_KHR_lock_surface_ENABLE
	/* These configs are for software rendering only, no client API support */
	/* EGL_KHR_lock_surface RGB565 */
	{
		16, 5, 6, 5, 0, 0, 6,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_LS_RGB_565, 0, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		0, 0, 1, 0,
		EGL_WINDOW_BIT | EGL_LOCK_SURFACE_BIT_KHR | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_R5G6B5, RENDER_METHOD_DIRECT_MODE, EGL_FORMAT_RGB_565_EXACT_KHR, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* EGL_KHR_lock_surface ARGB1555 */
	{
		16, 5, 5, 5, 0, 1, 6,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_LS_ARGB_1555, 0, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		0, 0, 1, 0,
		EGL_WINDOW_BIT | EGL_LOCK_SURFACE_BIT_KHR | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A1R5G5B5, RENDER_METHOD_DIRECT_MODE, EGL_FORMAT_RGB_565_KHR, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
#ifndef CONFIG_GLSE_RGBA32_DISABLE
	/* EGL_KHR_lock_surface BGRA8888 */
	{
		32, 8, 8, 8, 0, 8, 6,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_LS_BGRA_8888, 0, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		0, 0, 1, 0,
		EGL_WINDOW_BIT | EGL_LOCK_SURFACE_BIT_KHR | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_FORMAT_RGBA_8888_EXACT_KHR, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* EGL_KHR_lock_surface ARGB8888 */
	{
		32, 8, 8, 8, 0, 8, 6,
		EGL_FALSE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_LS_ARGB_8888, 0, 0, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		0, 0, 1, 0,
		EGL_WINDOW_BIT | EGL_LOCK_SURFACE_BIT_KHR | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_FORMAT_RGBA_8888_KHR, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
#if EGL_KHR_pixmap_lock_surface_ENABLE
	/* EGL_KHR_pixmap_lock_surface GLES 8888 */
	{
		32, 8, 8, 8, 0, 8, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_LS_GLES_8888, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, CONFIG_GLES_STENCIL_SIZE,
		EGL_PIXMAP_BIT | EGL_LOCK_SURFACE_BIT_KHR | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_FORMAT_RGBA_8888_EXACT_KHR, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
#endif
#endif
#endif /* EGL_KHR_lock_surface_ENABLE */

#ifdef EGL_EXTENDED_CONFIGS
	/* OpenGL ES 565 1x Zero Depth*/
	{
		16, 5, 6, 5, 0, 0, 0,
		EGL_TRUE, EGL_FALSE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_565_ZERO_DEPTH, CONFIG_GLES_BITS /*conformant*/, 0 /*depth*/, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_R5G6B5, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	#ifndef CONFIG_GLSE_RGBA32_DISABLE
	/* OpenGL ES 8888 1x Zero Depth*/
	{
		32, 8, 8, 8, 0, 8, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_8888_ZERO_DEPTH, CONFIG_GLES_BITS /*conformant*/, 0 /*depth*/, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenGL ES 8880 1x Zero Depth*/
	{
		32, 8, 8, 8, 0, 0, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_8880_ZERO_DEPTH, CONFIG_GLES_BITS /*conformant*/, 0 /*depth*/, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	/* OpenGL ES 8880 1x */
	{
		32, 8, 8, 8, 0, 0, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_8880, CONFIG_GLES_BITS /*conformant*/, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, 0, 0,
		CONFIG_GLES_BITS, 0, 0, 0,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_FALSE, EGL_FALSE
	},
	#endif
#endif /* EGL_EXTENDED_CONFIGS */
#ifndef CONFIG_GLSE_RGBA32_DISABLE
#ifdef HAVE_ANDROID_OS
	/* OpenGL ES 8888 1x BGRA - Android only*/
	{
		32, 8, 8, 8, 0, 8, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_NONE, CONFIG_ID_GLES_8888_BGRA32, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, HAL_PIXEL_FORMAT_BGRA_8888, 0,
		CONFIG_GLES_BITS, 0, 0, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_PBUFFER_BIT | EGL_PIXMAP_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_ANDROID_RECORDABLE_SUPPORTED, EGL_ANDROID_FRAMEBUFFER_TARGET_SUPPORTED 
	},
#if EGL_ANDROID_recordable_ENABLE	
	/*NON-CONFORMANCE config for android recordable surface YV12 only*/
	/* OpenGL ES 8888 1x */
	{
		32, 8, 8, 8, 0, 8, 0,
		EGL_TRUE, EGL_TRUE, EGL_RGB_BUFFER, EGL_SLOW_CONFIG, CONFIG_ID_RECORDABLE_YV12, CONFIG_GLES_BITS, CONFIG_GLES_DEPTH_SIZE, 0,
		MAX_PBUFFER_WIDTH, MAX_PBUFFER_HEIGHT, MAX_PBUFFER_PIXELS, MAX_SWAP_INTERVAL, MIN_SWAP_INTERVAL, EGL_TRUE, HAL_PIXEL_FORMAT_YV12, 0,
		CONFIG_GLES_BITS, 0, 0, CONFIG_GLES_STENCIL_SIZE,
		EGL_WINDOW_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
		EGL_NONE, EGL_DONT_CARE, EGL_DONT_CARE, EGL_DONT_CARE,
		MALI_PIXEL_FORMAT_A8R8G8B8, RENDER_METHOD_DIRECT_MODE, EGL_KHR_lock_surface_MATCH_FORMAT_NONE, EGL_SURFACE_SCALING_NOT_SUPPORTED, 
		EGL_ANDROID_RECORDABLE_SUPPORTED, EGL_FALSE
     },
#endif
#endif
#endif
};

/**
 * Initializes List of configurations
 */
EGLBoolean __egl_initialize_configs( EGLDisplay display_handle )
{
	u32 index = 0;
	egl_display *dpy = NULL;
	static const u32 num_configs = sizeof(__egl_configs_default_display) / sizeof(egl_config);
	dpy = __egl_get_display_ptr( display_handle );
	if ( NULL == dpy ) return EGL_FALSE;

	if ( NULL == dpy->configs )
	{
		dpy->configs = _mali_sys_malloc( num_configs * sizeof(egl_config) );
		if ( NULL == dpy->configs ) return EGL_FALSE;
	}
	dpy->num_configs = num_configs;
	_mali_sys_memcpy( dpy->configs, __egl_configs_default_display, num_configs * sizeof(egl_config) );

	for ( index = 0; index < num_configs; index++ )
	{
		__egl_add_config_handle( &dpy->configs[index], display_handle );
	}

#if EGL_BACKEND_X11 || HAVE_ANDROID_OS
	__egl_platform_filter_configs( dpy );
#endif

#if EGL_KHR_lock_surface_ENABLE
	__egl_lock_surface_initialize_configs( dpy );
#endif

#if EGL_FEATURE_SURFACE_SCALING_ENABLE
    __egl_surface_scaling_initialize_configs( dpy );
#endif

	return EGL_TRUE;
}

EGLBoolean _egl_config_support_pixmap( egl_display *display, EGLNativePixmapType pixmap )
{
	egl_config *config = NULL;
	u32 iterator = 0;

	MALI_DEBUG_ASSERT_POINTER( display );

	config = (egl_config *)__mali_named_list_iterate_begin( display->config, &iterator );
	while ( NULL != config )
	{
		/* to be compatible with the pixmap we need that
		 * 1. the config has EGL_PIXMAP_BIT set
		 * 2. the config bpp matches the pixmap bpp exactly
		 */

		if ( (config->surface_type & EGL_PIXMAP_BIT) )
		{
			if ( EGL_TRUE == __egl_platform_pixmap_config_compatible( display->native_dpy, pixmap, config, EGL_FALSE ) )
			{
				return EGL_TRUE;
			}
		}
		config = (egl_config *)__mali_named_list_iterate_next( display->config, &iterator );
	}

	return EGL_FALSE;
}

EGLBoolean _egl_get_configs( EGLDisplay __dpy, EGLConfig *__configs,
                             EGLint config_size, EGLint *num_config, void *thread_state )
{
	egl_display *dpy = NULL;
	EGLConfig ** configs = (EGLConfig**)__configs;
	__egl_thread_state *tstate = (__egl_thread_state *)thread_state;
	EGLint num_total_config = 0;

	MALI_CHECK( EGL_NO_DISPLAY != (dpy = __egl_get_check_display( __dpy, tstate ) ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_display_initialized( dpy, tstate ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_null_value( num_config, EGL_BAD_PARAMETER, tstate ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_display_not_terminating( dpy, tstate ), EGL_FALSE );

	num_total_config = (EGLint)__mali_named_list_size( dpy->config );

	/* if we have no destination to write the configs, we'll just output the number of total configs */
	if ( NULL == configs )
	{
		*num_config = num_total_config;
		return EGL_TRUE;
	}

	if ( num_total_config < config_size ) config_size = num_total_config;

	*num_config = __egl_get_config_handles( &__configs[0], __dpy, config_size );

	return EGL_TRUE;
}

/**
 * @brief Initializes a config to default search settings for eglChooseConfig.
 * @note See EGL 1.4 spec, table 3.4
 * @param config pointer to a config, config should be memset to zero before passing to this function
 */
MALI_STATIC void __egl_set_config_defaults( egl_config *config )
{
	config->bind_to_texture_rgb     = EGL_DONT_CARE;
	config->bind_to_texture_rgba    = EGL_DONT_CARE;
	config->color_buffer_type       = EGL_RGB_BUFFER;
	config->config_caveat           = EGL_DONT_CARE;
	config->config_id               = EGL_DONT_CARE;
	config->max_swap_interval       = EGL_DONT_CARE;
	config->min_swap_interval       = EGL_DONT_CARE;
	config->native_renderable       = EGL_DONT_CARE;
	config->native_visual_type      = EGL_DONT_CARE;
	config->renderable_type         = EGL_OPENGL_ES_BIT;
	config->surface_type            = EGL_WINDOW_BIT;
	config->transparent_type        = EGL_NONE;
	config->transparent_red_value   = EGL_DONT_CARE;
	config->transparent_green_value = EGL_DONT_CARE;
	config->transparent_blue_value  = EGL_DONT_CARE;
	config->match_format_khr        = EGL_DONT_CARE;
    config->surface_scaling         = EGL_DONT_CARE;
#if EGL_ANDROID_recordable_ENABLE
	config->recordable_android      = EGL_DONT_CARE;
#endif
#if EGL_ANDROID_framebuffer_target_ENABLE
	config->framebuffer_target_android = EGL_DONT_CARE;
#endif
}

/**
 * @brief Parses an attribute list given to eglChooseConfig
 * @param tstate thread state
 * @param attrib_list the attrib_list
 * @param config the config to store attributes into
 * @param match_mative_pixmap place to store any native pixmap handle
 * @param match_native_pixmap_specified set to EGL_TRUE if found
 * @return EGL_TRUE on success, EGL_FALSE on failure
 */
MALI_STATIC EGLBoolean __egl_parse_config_attribute_list( __egl_thread_state *tstate, const EGLint *attrib_list,
                                                     egl_config *config, EGLNativePixmapType *match_native_pixmap,
                                                     EGLBoolean *match_native_pixmap_specified )
{

/* Helper macros that signals error if attribute values are not in range and not equal to EGL_DONT_CARE */
/* This will perform arg1 = arg2, if arg2 > 0*/
#define ASSIGN_IF_NON_NEGATIVE(destination, source) \
do { \
	if ( EGL_DONT_CARE != (source) && 0 > (source) ) \
	{ \
		__egl_set_error( EGL_BAD_ATTRIBUTE, tstate ); \
		return EGL_FALSE; \
	} \
	destination = (source); \
} while (0)

/* This will perform assignment if source is EGL_DONT_CARE, EGL_TRUE or EGL_FALSE */
#define ASSIGN_IF_BOOL(destination, source) \
do { \
	if ( EGL_DONT_CARE != (source) && EGL_TRUE != (source) && EGL_FALSE != (source) ) \
	{ \
		__egl_set_error( EGL_BAD_ATTRIBUTE, tstate ); \
		return EGL_FALSE; \
	} \
	destination = (source); \
} while (0)

/* Assigns source to destination, if source is listed in the array "list" */
#define ASSIGN_IF_IN_LIST(destination, source, list) \
do { \
	u32 t; \
	for ( t = 0; t < sizeof(list) / sizeof(EGLint); ++t ) \
	{ \
		if ( (source) == list[t] ) \
		{ \
			destination = (source); \
			break; \
		} \
	} \
	if ( sizeof(list) / sizeof(EGLint) == t ) \
	{ \
		__egl_set_error( EGL_BAD_ATTRIBUTE, tstate ); \
		return EGL_FALSE; \
	} \
} while (0)

#define ASSIGN_IF_IN_BITMASK(destination, source, bitmask) \
do { \
	if ( ( EGL_DONT_CARE != (source) && (~(bitmask) & (source)) != 0 ) ) \
	{ \
		__egl_set_error( EGL_BAD_ATTRIBUTE, tstate ); \
		return EGL_FALSE; \
	} \
	destination = (source); \
} while (0)

	/* Arrays with allowed values for some config attributes */
	static const EGLint allowed_color_buffer_type_values[] = { EGL_DONT_CARE, EGL_RGB_BUFFER, EGL_LUMINANCE_BUFFER };
	static const EGLint allowed_config_caveat_values[] = { EGL_DONT_CARE, EGL_NONE, EGL_SLOW_CONFIG, EGL_NON_CONFORMANT_CONFIG };
	static const EGLint allowed_transparent_type_values[] = { EGL_DONT_CARE, EGL_NONE, EGL_TRANSPARENT_RGB };
	static const EGLint allowed_sample_buffers_values[] = { EGL_DONT_CARE, 0, 1 };
#if EGL_KHR_lock_surface_ENABLE
	static const EGLint allowed_match_format_values[] = { EGL_DONT_CARE, EGL_NONE, EGL_FORMAT_RGB_565_EXACT_KHR, EGL_FORMAT_RGB_565_KHR, EGL_FORMAT_RGBA_8888_EXACT_KHR, EGL_FORMAT_RGBA_8888_KHR };
#endif

	mali_bool done = MALI_FALSE;
	EGLint *attrib = (EGLint*) attrib_list;

	if ( NULL == attrib_list ) return EGL_TRUE;

	MALI_DEBUG_ASSERT_POINTER( config );

	while ( done != MALI_TRUE )
	{
		switch ( attrib[0] )
		{
			case EGL_BUFFER_SIZE:          ASSIGN_IF_NON_NEGATIVE( config->buffer_size, attrib[1] ); break;
			case EGL_RED_SIZE:             ASSIGN_IF_NON_NEGATIVE( config->red_size, attrib[1] ); break;
			case EGL_GREEN_SIZE:           ASSIGN_IF_NON_NEGATIVE( config->green_size, attrib[1] ); break;
			case EGL_BLUE_SIZE:            ASSIGN_IF_NON_NEGATIVE( config->blue_size, attrib[1] ); break;
			case EGL_LUMINANCE_SIZE:       ASSIGN_IF_NON_NEGATIVE( config->luminance_size, attrib[1] ); break;
			case EGL_ALPHA_SIZE:           ASSIGN_IF_NON_NEGATIVE( config->alpha_size, attrib[1] ); break;
			case EGL_ALPHA_MASK_SIZE:      ASSIGN_IF_NON_NEGATIVE( config->alpha_mask_size, attrib[1] ); break;
			case EGL_BIND_TO_TEXTURE_RGB:  ASSIGN_IF_BOOL( config->bind_to_texture_rgb, attrib[1] ); break;
			case EGL_BIND_TO_TEXTURE_RGBA: ASSIGN_IF_BOOL( config->bind_to_texture_rgba, attrib[1] ); break;
			case EGL_COLOR_BUFFER_TYPE:    ASSIGN_IF_IN_LIST( config->color_buffer_type, attrib[1], allowed_color_buffer_type_values ); break;
			case EGL_CONFIG_CAVEAT:        ASSIGN_IF_IN_LIST( config->config_caveat, attrib[1], allowed_config_caveat_values ); break;
			case EGL_CONFIG_ID:            config->config_id = attrib[1]; break; /* must verify id in choose_config */
			case EGL_CONFORMANT:           ASSIGN_IF_IN_BITMASK( config->conformant, attrib[1], EGL_OPENGL_BIT | EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT | EGL_OPENVG_BIT ); break;
			case EGL_DEPTH_SIZE:           ASSIGN_IF_NON_NEGATIVE( config->depth_size, attrib[1] ); break;
			case EGL_LEVEL:
				config->level = attrib[1];
				break;

			case EGL_MATCH_NATIVE_PIXMAP:
				MALI_DEBUG_ASSERT_POINTER( match_native_pixmap );
				MALI_DEBUG_ASSERT_POINTER( match_native_pixmap_specified );
				*match_native_pixmap  = (EGLNativePixmapType)attrib[1];
				*match_native_pixmap_specified = EGL_TRUE;
				break;

			case EGL_MAX_SWAP_INTERVAL:    ASSIGN_IF_NON_NEGATIVE( config->max_swap_interval, attrib[1] ); break;
			case EGL_MIN_SWAP_INTERVAL:    ASSIGN_IF_NON_NEGATIVE( config->min_swap_interval, attrib[1] ); break;
			case EGL_NATIVE_RENDERABLE:    ASSIGN_IF_BOOL( config->native_renderable, attrib[1] ); break;
			case EGL_NATIVE_VISUAL_TYPE:      config->native_visual_type   = attrib[1]; break;
			case EGL_RENDERABLE_TYPE:      ASSIGN_IF_IN_BITMASK( config->renderable_type, attrib[1], EGL_OPENGL_BIT | EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT | EGL_OPENVG_BIT ); break;
			case EGL_SAMPLE_BUFFERS:       ASSIGN_IF_IN_LIST( config->sample_buffers, attrib[1], allowed_sample_buffers_values ); break;
			case EGL_SAMPLES:              ASSIGN_IF_NON_NEGATIVE( config->samples, attrib[1] ); break;
			case EGL_STENCIL_SIZE:         ASSIGN_IF_NON_NEGATIVE( config->stencil_size, attrib[1] ); break;
			case EGL_SURFACE_TYPE:
#if EGL_KHR_lock_surface_ENABLE
				ASSIGN_IF_IN_BITMASK( config->surface_type, attrib[1], EGL_WINDOW_BIT | EGL_PIXMAP_BIT | EGL_PBUFFER_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_VG_COLORSPACE_LINEAR_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT | EGL_LOCK_SURFACE_BIT_KHR | EGL_OPTIMAL_FORMAT_BIT_KHR );
#else
				ASSIGN_IF_IN_BITMASK( config->surface_type, attrib[1], EGL_WINDOW_BIT | EGL_PIXMAP_BIT | EGL_PBUFFER_BIT | EGL_MULTISAMPLE_RESOLVE_BOX_BIT | EGL_SWAP_BEHAVIOR_PRESERVED_BIT | EGL_VG_COLORSPACE_LINEAR_BIT | EGL_VG_ALPHA_FORMAT_PRE_BIT );
#endif
				break;
			case EGL_TRANSPARENT_TYPE:        ASSIGN_IF_IN_LIST( config->transparent_type, attrib[1], allowed_transparent_type_values ); break;
			case EGL_TRANSPARENT_RED_VALUE:   ASSIGN_IF_NON_NEGATIVE( config->transparent_red_value, attrib[1] ); break;
			case EGL_TRANSPARENT_GREEN_VALUE: ASSIGN_IF_NON_NEGATIVE( config->transparent_green_value, attrib[1] ); break;
			case EGL_TRANSPARENT_BLUE_VALUE:  ASSIGN_IF_NON_NEGATIVE( config->transparent_blue_value, attrib[1] ); break;
			/* EGL 1.4 spec, section 3.4.1,
			 * "If EGL_MAX_PBUFFER_WIDTH, EGL_MAX_PBUFFER_HEIGHT,
			 *  EGL_MAX_PBUFFER_PIXELS or EGL_NATIVE_VISUAL_ID are specified in
			 *  attrib_list, then they are ignored"
			 */
			case EGL_MAX_PBUFFER_WIDTH:
			case EGL_MAX_PBUFFER_HEIGHT:
			case EGL_MAX_PBUFFER_PIXELS:
			case EGL_NATIVE_VISUAL_ID:
				break;

#if EGL_KHR_lock_surface_ENABLE
			case EGL_MATCH_FORMAT_KHR: ASSIGN_IF_IN_LIST( config->match_format_khr, attrib[1], allowed_match_format_values ); break;
#endif

#if EGL_FEATURE_SURFACE_SCALING_ENABLE
            case EGL_FEATURE_SURFACE_SCALING_CONFIG_NAME: ASSIGN_IF_BOOL( config->surface_scaling, attrib[1] ); break;
#endif
#if EGL_ANDROID_recordable_ENABLE
			/*RECORDABLE_ANDROID*/
			case EGL_RECORDABLE_ANDROID: ASSIGN_IF_BOOL( config->recordable_android, attrib[1] ); break;
#endif
#if EGL_ANDROID_framebuffer_target_ENABLE
			case EGL_FRAMEBUFFER_TARGET_ANDROID: ASSIGN_IF_BOOL( config->framebuffer_target_android, attrib[1] ); break;
#endif
			case EGL_NONE:
				done = MALI_TRUE;
				break;

			default:
				/* faulty in-parameter, set error and exit */
				__egl_set_error( EGL_BAD_ATTRIBUTE, tstate );
				return EGL_FALSE;
		}
		attrib += 2;
	}

	return EGL_TRUE;

#undef ASSIGN_IF_IN_BITMASK
#undef ASSIGN_IF_IN_LIST
#undef ASSIGN_IF_BOOL
#undef ASSIGN_IF_NON_NEGATIVE
}

/**
 * @brief Quicksort callback function for sorting the configurations
 * @param a void* to first variable
 * @param b void* to second variable
 * @return compare
 */
EGLint egl_compare_func( const void *a, const void *b )
{
	EGLConfig config_handle[2];
	EGLint comp = 0;
	EGLint color_size[2];
	egl_config *config[2];

	/* Sort order:
	 * 1: EGL_CONFIG_CAVEAT (special, precedence is EGL_NONE, EGL_SLOW_CONFIG, EGL_NON_CONFORMANT_CONFIG)
	 * 2: EGL_COLOR_BUFFER_TYPE (special, precedence is EGL_RGB_BUFFER, EGL_LUMINANCE_BUFFER)
	 * 3: EGL_RED_SIZE+EGL_GREEN_SIZE+EGL_BLUE_SIZE+EGL_ALPHA_SIZE(rgb color buffer), EGL_LUMINANCE_SIZE+EGL_ALPHA_SIZE (luminance buffer), smaller
	 * 4: EGL_BUFFER_SIZE, smaller
	 * 5: EGL_SAMPLE_BUFFERS, smaller
	 * 6: EGL_SAMPLES, smaller
	 * 7: EGL_DEPTH_SIZE, smaller
	 * 8: EGL_STENCIL_SIZE, smaller
	 * 9: EGL_ALPHA_MASK_SIZE, smaller
	 *10: EGL_NATIVE_VISUAL_TYPE (special, implementation-defined)
	 *11: EGL_CONFIG_ID, smaller (guarantees unique ordering)
	 */

	config_handle[0] = *(EGLConfig*)a;
	config_handle[1] = *(EGLConfig*)b;

	config[0] = __egl_get_config_ptr( config_handle[0], __egl_config_display );
	config[1] = __egl_get_config_ptr( config_handle[1], __egl_config_display );

	/* caveat */
	comp = (EGLint)(config[0]->config_caveat - config[1]->config_caveat);
	if ( 0 != comp ) return comp;

	/* color buffer type */
	comp = (EGLint)(config[0]->color_buffer_type - config[1]->color_buffer_type);
	if ( 0 != comp ) return comp;

	/* total number of color bits */
	if( EGL_RGB_BUFFER == config[0]->color_buffer_type )
	{
		EGLBoolean r = (__egl_config_color_components>>0) & 0x1;
		EGLBoolean g = (__egl_config_color_components>>1) & 0x1;
		EGLBoolean b = (__egl_config_color_components>>2) & 0x1;
		EGLBoolean a = (__egl_config_color_components>>3) & 0x1;

		color_size[0] = (r ? config[0]->red_size : 0) + (g ? config[0]->green_size : 0) + (b ? config[0]->blue_size : 0) + (a ? config[0]->alpha_size : 0);
		color_size[1] = (r ? config[1]->red_size : 0) + (g ? config[1]->green_size : 0) + (b ? config[1]->blue_size : 0) + (a ? config[1]->alpha_size : 0);
	}
	else
	{
		EGLBoolean a = (__egl_config_color_components>>3) & 0x1;
		EGLBoolean l = (__egl_config_color_components>>4) & 0x1;

		color_size[0] = (l ? config[0]->luminance_size : 0) + (a ? config[0]->alpha_size : 0);
		color_size[1] = (l ? config[1]->luminance_size : 0) + (a ? config[1]->alpha_size : 0);
	}

	comp = (EGLint)(color_size[1] - color_size[0]);
	if ( 0 != comp ) return comp;

	/* buffer size */
	comp = (EGLint)(config[0]->buffer_size - config[1]->buffer_size);
	if ( 0 != comp ) return comp;

	/* sample buffers */
	comp = (EGLint)(config[0]->sample_buffers - config[1]->sample_buffers);
	if ( 0 != comp ) return comp;

	/* samples */
	comp = (EGLint)(config[0]->samples - config[1]->samples);
	if ( 0 != comp ) return comp;

	/* depth size */
	comp = (EGLint)(config[0]->depth_size - config[1]->depth_size);
	if ( 0 != comp ) return comp;

	/* stencil size */
	comp = (EGLint)(config[0]->stencil_size - config[1]->stencil_size);
	if ( 0 != comp ) return comp;

	/* alpha mask size */
	comp = (EGLint)(config[0]->alpha_mask_size - config[1]->alpha_mask_size);
	if ( 0 != comp ) return comp;

	/* native visual type */

	/* config id */
	comp = (EGLint)(config[0]->config_id - config[1]->config_id);

	return comp;
}

EGLBoolean _egl_choose_config( EGLDisplay __dpy,
                               const EGLint *attrib_list,
                               EGLConfig *__configs,
                               EGLint config_size,
                               EGLint *num_config, void *thread_state )
{
	egl_display* dpy = NULL;
	egl_config *cfg = NULL;
	egl_config config;
	__egl_thread_state *tstate = (__egl_thread_state *)thread_state;
	u32 iterator;
	const u32 max_match_count = MALI_ARRAY_SIZE(__egl_configs_default_display);
	EGLConfig config_matches[MALI_ARRAY_SIZE(__egl_configs_default_display)];
	u32 matches_found = 0;

	EGLBoolean match_native_pixmap_specified = EGL_FALSE;
	EGLNativePixmapType match_native_pixmap = (EGLNativePixmapType)NULL;

	MALI_CHECK( EGL_NO_DISPLAY != (dpy = __egl_get_check_display( __dpy, tstate ) ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_display_initialized( dpy, tstate ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_null_value( num_config, EGL_BAD_PARAMETER, tstate ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_display_not_terminating( dpy, tstate ), EGL_FALSE );

	_mali_sys_memset( &config, 0, sizeof(egl_config) );
	__egl_set_config_defaults( &config );
	MALI_CHECK( EGL_TRUE == __egl_parse_config_attribute_list( tstate, attrib_list, &config, &match_native_pixmap, &match_native_pixmap_specified ), EGL_FALSE );

	*num_config = 0;

	/* if level = -1 return EGL_TRUE with 0 configs */
	
	
	/* if config id was specified, ignore other attribs and return the config */
	if ( EGL_DONT_CARE != config.config_id )
	{
		/* find config id in configs */
		if (config_size >= 1)
		{
			EGLConfig config_by_id;

			config_by_id = __egl_get_config_handle_by_id( config.config_id, __dpy );
			if ( (EGLConfig)NULL != config_by_id )
			{
				*num_config = 1;
				if ( NULL != __configs ) __configs[0] = config_by_id;
			}
			return EGL_TRUE;
		}
		return EGL_TRUE;
	}

	/* EGL 1.4 spec, section 3.4.1,
	 * "If EGL_SURFACE_TYPE is specified in attrib list and the mask that follows
	 *  does not have EGL_WINDOW_BIT set, or if there are no native visual types,
	 *  then the EGL_NATIVE_VISUAL TYPE attribute is ignored."
	 */
	if ( !(config.surface_type & EGL_WINDOW_BIT) )
	{
		config.native_visual_type = EGL_DONT_CARE;
	}

	/* ignore transparent color values if transparent type is set to none */
	if ( EGL_NONE == config.transparent_type )
	{
		config.transparent_red_value = EGL_DONT_CARE;
		config.transparent_green_value = EGL_DONT_CARE;
		config.transparent_blue_value = EGL_DONT_CARE;
	}

	/* if EGL_MATCH_NATIVE_PIXMAP was specified, verify that the pixmap handle is valid */
	if ( EGL_TRUE == match_native_pixmap_specified )
	{
		if ( EGL_FALSE == __egl_platform_pixmap_valid( match_native_pixmap ) )
		{
			__egl_set_error( EGL_BAD_NATIVE_PIXMAP, tstate );
			return EGL_FALSE;
		}
		config.surface_type = EGL_PIXMAP_BIT;
	}

	/* search for matching configs and output them */
	cfg = (egl_config *)__mali_named_list_iterate_begin( dpy->config, &iterator );
	while ( NULL != cfg )
	{	
		/*
		 some macros to make the code a bit maintainable.
		 note that the local variables and the struct-members must be
		 named in the same way for this to work
		*/
		#define TEST_BIGGER(x) (((EGLint)(config.x) == EGL_DONT_CARE) || ((cfg->x) >= (config.x)))
		#define TEST_EXACT(x) (((EGLint)(config.x) == EGL_DONT_CARE) || ((cfg->x) == (config.x)))
		#define TEST_MASK(x) (((EGLint)(config.x) == EGL_DONT_CARE) || (((cfg->x) & (config.x)) == (config.x)))
		#define TEST_MASK_CONFORMANT(x) ((config.x) == 0 || (cfg->x) & (config.x))
		if ( TEST_BIGGER(buffer_size) &&
		     TEST_BIGGER(red_size) &&
		     TEST_BIGGER(green_size) &&
		     TEST_BIGGER(blue_size) &&
		     TEST_BIGGER(luminance_size) &&
		     TEST_BIGGER(alpha_size) &&
		     TEST_BIGGER(alpha_mask_size) &&
		     TEST_EXACT(bind_to_texture_rgb) &&
		     TEST_EXACT(bind_to_texture_rgba) &&
		     TEST_EXACT(color_buffer_type) &&
		     TEST_EXACT(config_caveat) &&
		     TEST_EXACT(config_id) &&
		     TEST_MASK_CONFORMANT(conformant) &&
		     TEST_BIGGER(depth_size) &&
		     TEST_EXACT(level) &&
		     TEST_EXACT(max_swap_interval) &&
		     TEST_EXACT(min_swap_interval) &&
		     TEST_EXACT(native_renderable) &&
		     TEST_EXACT(native_visual_type) &&
		     TEST_MASK(renderable_type) &&
		     TEST_BIGGER(sample_buffers) &&
		     TEST_BIGGER(samples) &&
		     TEST_BIGGER(stencil_size) &&
		     TEST_MASK(surface_type) &&
#if EGL_KHR_lock_surface_ENABLE
		     TEST_EXACT(match_format_khr) &&
#endif
#if EGL_FEATURE_SURFACE_SCALING_ENABLE
		     TEST_EXACT(surface_scaling) && 
#endif
#if EGL_ANDROID_recordable_ENABLE
			TEST_EXACT(recordable_android)&&
#endif
#if EGL_ANDROID_framebuffer_target_ENABLE
		     TEST_EXACT(framebuffer_target_android) &&
#endif
		     TEST_EXACT(transparent_type) &&
		     TEST_EXACT(transparent_red_value) &&
		     TEST_EXACT(transparent_green_value) &&
		     TEST_EXACT(transparent_blue_value))
		{
			if ( EGL_TRUE == match_native_pixmap_specified )
			{
				if ( EGL_FALSE == __egl_platform_pixmap_config_compatible( dpy->native_dpy, match_native_pixmap, cfg, EGL_TRUE ) )
				{
					cfg = (egl_config *)__mali_named_list_iterate_next( dpy->config, &iterator );
					continue;
				}
			}

			if (matches_found < max_match_count)
			{							
				config_matches[matches_found] = HANDLE_EGL_CONFIG(iterator);
				matches_found++;
			}
		}
		#undef TEST_BIGGER
		#undef TEST_EXACT
		#undef TEST_MASK
		#undef TEST_MASK_CONFORMANT
		cfg = (egl_config *)__mali_named_list_iterate_next( dpy->config, &iterator );
	}

	/* total number of matching configs is returned if configs is NULL,
	 * no matter what config_size is set to
	 */
	if ( NULL == __configs )
	{
		*num_config = matches_found;
		return EGL_TRUE;
	}

	if ( 0 == matches_found || config_size <= 0 ) return EGL_TRUE; /* no matches found or no space to return any matches */

	/* set the global display handle to point to the current display */
	__egl_config_display = __dpy;

	/* Set the global color component sort attrib (bitmask)
	 * A set bit indicates that a value has been given for the color component,
	 * and that sorting should consider this color component
	 */
	__egl_config_color_components = 0;
	if ( config.red_size > 0 )   __egl_config_color_components |= 1<<0;
	if ( config.green_size > 0 ) __egl_config_color_components |= 1<<1;
	if ( config.blue_size > 0 )  __egl_config_color_components |= 1<<2;
	if ( config.alpha_size > 0 ) __egl_config_color_components |= 1<<3;
	if ( config.luminance_size > 0 ) __egl_config_color_components |= 1<<4;

	/* sort matches */
	_mali_sys_qsort( (void*)config_matches, (u32)matches_found, sizeof(EGLConfig), egl_compare_func );

	/* return the best min(config_size, matches_found) found */
	_mali_sys_memcpy( __configs, config_matches, sizeof(EGLConfig) * MIN(config_size, (EGLint)matches_found) );
	*num_config = MIN(config_size, (EGLint)matches_found);

	return EGL_TRUE;
}

EGLBoolean _egl_get_config_attrib( EGLDisplay __dpy, EGLConfig __config,
                                   EGLint attribute, EGLint *value, void *thread_state )
{
	egl_display *dpy = NULL;
	egl_config *config = NULL;
	__egl_thread_state *tstate = (__egl_thread_state *)thread_state;

	MALI_CHECK( EGL_NO_DISPLAY != (dpy = __egl_get_check_display( __dpy, tstate ) ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_display_initialized( dpy, tstate ), EGL_FALSE );
	MALI_CHECK( NULL != (config = __egl_get_check_config( __config, __dpy, tstate ) ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_null_value( value, EGL_BAD_PARAMETER, tstate ), EGL_FALSE );
	MALI_CHECK( EGL_TRUE == __egl_check_display_not_terminating( dpy, tstate ), EGL_FALSE );

	/* return data from the config according to the input. */
	switch ( attribute )
	{
		case EGL_BUFFER_SIZE:               *value = config->buffer_size;             break;
		case EGL_RED_SIZE:                  *value = config->red_size;                break;
		case EGL_GREEN_SIZE:                *value = config->green_size;              break;
		case EGL_BLUE_SIZE:                 *value = config->blue_size;               break;
		case EGL_ALPHA_SIZE:                *value = config->alpha_size;              break;
		case EGL_LUMINANCE_SIZE:            *value = config->luminance_size;          break;
		case EGL_ALPHA_MASK_SIZE:           *value = config->alpha_mask_size;         break;
		case EGL_BIND_TO_TEXTURE_RGB:       *value = config->bind_to_texture_rgb;     break;
		case EGL_BIND_TO_TEXTURE_RGBA:      *value = config->bind_to_texture_rgba;    break;
		case EGL_COLOR_BUFFER_TYPE:         *value = config->color_buffer_type;       break;
		case EGL_CONFIG_CAVEAT:             *value = config->config_caveat;           break;
		case EGL_CONFIG_ID:                 *value = config->config_id;               break;
		case EGL_CONFORMANT:                *value = config->conformant;              break;
		case EGL_DEPTH_SIZE:                *value = config->depth_size;              break;
		case EGL_LEVEL:                     *value = config->level;                   break;
		case EGL_MAX_PBUFFER_WIDTH:         *value = config->max_pbuffer_width;       break;
		case EGL_MAX_PBUFFER_HEIGHT:        *value = config->max_pbuffer_height;      break;
		case EGL_MAX_PBUFFER_PIXELS:        *value = config->max_pbuffer_pixels;      break;
		case EGL_MAX_SWAP_INTERVAL:         *value = config->max_swap_interval;       break;
		case EGL_MIN_SWAP_INTERVAL:         *value = config->min_swap_interval;       break;
		case EGL_NATIVE_RENDERABLE:         *value = config->native_renderable;       break;
		case EGL_NATIVE_VISUAL_ID:          *value = config->native_visual_id;        break;
		case EGL_NATIVE_VISUAL_TYPE:        *value = config->native_visual_type;      break;
		case EGL_RENDERABLE_TYPE:           *value = config->renderable_type;         break;
		case EGL_SAMPLE_BUFFERS:            *value = config->sample_buffers;          break;
		case EGL_SAMPLES:                   *value = config->samples;                 break;
		case EGL_STENCIL_SIZE:              *value = config->stencil_size;            break;
		case EGL_SURFACE_TYPE:              *value = config->surface_type;            break;
		case EGL_TRANSPARENT_TYPE:          *value = config->transparent_type;        break;
		case EGL_TRANSPARENT_RED_VALUE:     *value = config->transparent_red_value;   break;
		case EGL_TRANSPARENT_GREEN_VALUE:   *value = config->transparent_green_value; break;
		case EGL_TRANSPARENT_BLUE_VALUE:    *value = config->transparent_blue_value;  break;
#if EGL_KHR_lock_surface_ENABLE
		case EGL_MATCH_FORMAT_KHR:          *value = config->match_format_khr;        break;
#endif
#if EGL_FEATURE_SURFACE_SCALING_ENABLE
		case EGL_FEATURE_SURFACE_SCALING_CONFIG_NAME:    *value = config->surface_scaling;         break;
#endif
#if EGL_ANDROID_recordable_ENABLE
		case EGL_RECORDABLE_ANDROID: *value= config->recordable_android; break;
#endif
#if EGL_ANDROID_framebuffer_target_ENABLE
		case EGL_FRAMEBUFFER_TARGET_ANDROID: *value = config->framebuffer_target_android; break;
#endif

		default:
			/* bad attrib requested */
			__egl_set_error( EGL_BAD_ATTRIBUTE, tstate );
			return EGL_FALSE;
	}

	return EGL_TRUE;
}

