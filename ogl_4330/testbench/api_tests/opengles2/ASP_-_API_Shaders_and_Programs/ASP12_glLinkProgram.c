/*
 * This confidential and proprietary software may be used only as
 * authorised by a licensing agreement from ARM Limited
 * (C) COPYRIGHT 2007-2011 ARM Limited
 * ALL RIGHTS RESERVED
 * The entire notice above must be reproduced on all authorised
 * copies and copies may only be made to the extent permitted
 * by a licensing agreement from ARM Limited.
 */

/*
 *
 * CASE #1 - Call function with a program not generated by opengl
 *			 Result: Error set to INVALID_VALUE
 * CASE #2 - Call function with a shader id
  *			 Result:
 * CASE #3 - Call function on an empty unlinked program object
 *			 Result:
 * CASE #4 - Call function with one uncompiled vertex shader attached
 *			 Result:
 * CASE #5 - As 4, but assign a legal source to the shader, and compile it.
 *			 Result:
 * CASE #6 - As 5, also attach a legal fragment shader and compile that too
 *			 Result:
 */

#include "../gl2_framework.h"
#include <suite.h>


static void test_glLinkProgram(suite* test_suite)
{
	GLuint program, vs;
	GLenum err;
	GLint linkStatus=0;
	GLubyte buffer[1000];
	GLsizei programInfoLogLength=0;

	/*
	* CASE #1 - Call function with a program not generated by opengl
	*/

	/* Should generate GL_INVALID_VALUE */
	glLinkProgram(100000);
	err = glGetError();
	ASSERT_GLENUMS_EQUAL(err, GL_INVALID_VALUE);

	/*
	* CASE #2 - Call function with a shader id
	*/

	/* create a valid shade ID */
	vs = glCreateShader(GL_VERTEX_SHADER);
	ASSERT_INTS_DIFFER(vs, 0);

	glLinkProgram(vs);
	err = glGetError();
	ASSERT_GLENUMS_EQUAL(err, GL_INVALID_OPERATION);

	/* cleanup */
	glDeleteShader(vs);
	vs = 0;

	/*
	* CASE #3 - Call function on an empty unlinked program object
	*/

	/* create a valid program ID */
	program = glCreateProgram();
	ASSERT_INTS_DIFFER(program, 0);

	glLinkProgram(program);

	err = glGetError();
	ASSERT_GLENUMS_EQUAL(err, GL_NO_ERROR);

	/* Ensur that the link status is set to false */
	glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
	ASSERT_INTS_EQUAL(linkStatus, GL_FALSE);

	/* Verify that the info log contains a null-terminated error message */
	glGetProgramInfoLog(program, 1000, &programInfoLogLength, (char*)buffer);
	assert_fail((programInfoLogLength > 0), "CASE #3 error: info log contains no data");
	ASSERT_INTS_EQUAL((int)buffer[programInfoLogLength], (int)('\0'));

	/* cleanup */
	glDeleteProgram(program);
	program = 0;


	/*
	* CASE #4 - Call function with one uncompiled vertex shader attached
	*/

	/* create a valid program ID */
	program = glCreateProgram();
	ASSERT_INTS_DIFFER(program, 0);

	/* create a valid vs ID */
	vs = glCreateShader(GL_VERTEX_SHADER);
	ASSERT_INTS_DIFFER(vs, 0);


	/* Attach uncompiled vertexshader to the program */
	glAttachShader(program, vs);

	/* Attempt to link the incomplete program, this should generate no gl-errors */
	glLinkProgram(program);

/* This generates an error on nvidia */
#ifndef TESTBENCH_DESKTOP_GL
	err = glGetError();
	ASSERT_GLENUMS_EQUAL(err, GL_NO_ERROR);
#endif

	/* Assert link status set to false */
	glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
	ASSERT_INTS_EQUAL(linkStatus, GL_FALSE);

	/* Verify that the info log contains a null-terminated error message */
	glGetProgramInfoLog(program, 1000, &programInfoLogLength, (char*)buffer);
	assert_fail((programInfoLogLength > 0), "CASE #4 error: info log contains no data");
	ASSERT_INTS_EQUAL((int)buffer[programInfoLogLength], (int)('\0'));

	glDetachShader(program, vs);
	glDeleteShader(vs);
	vs = 0;
	glDeleteProgram(program);
	program = 0;



	/*
	* CASE #5 -  As 4, but assign a legal source to the shader, and compile it.
	*/

	/* create a valid program ID */
	program = glCreateProgram();
	ASSERT_INTS_DIFFER(program, 0);

	/* create a valid vs ID */
	vs = glCreateShader(GL_VERTEX_SHADER);
	ASSERT_INTS_DIFFER(vs, 0);

	glAttachShader(program, vs);

#ifdef USING_BINARY_SHADERS
	{
		int len;
#ifdef __SYMBIAN32__
		void* vshader = load_file("z:\\Shaders\\pass_two_attribs.vert.binshader", &len, "rb");
#else
		void* vshader = load_file("shaders/pass_two_attribs.vert.binshader", &len, "rb");
#endif
		if(!vshader)
		{
			printf("Unable to load shaders/pass_two_attribs.vert.binshader\n");
			assert_fatal( 0, "Could not load shaders/pass_two_attribs.vert.binshader" );
		}
		glShaderBinary(1, &vs, GL_MALI_SHADER_BINARY_ARM, vshader, len);
		FREE (vshader);
	}
#else
	{
		int len;
#ifdef __SYMBIAN32__
		char* vshader = (char*)load_file("z:\\Shaders\\pass_two_attribs.vert.glsl", &len, "r");
#else
		char* vshader = (char*)load_file("shaders/pass_two_attribs.vert.glsl", &len, "r");
#endif
		if(!vshader)
		{
			printf("Unable to load shaders/pass_two_attribs.vert.glsl\n");
			assert_fatal( 0, "Could not load shaders/pass_two_attribs.vert.glsl" );
		}
		glShaderSource(vs, 1, (const char**)&vshader, NULL);
		glCompileShader(vs);
		FREE(vshader);
	}
#endif
	/* Attempt to link the program without a valid fragment shader, this should generate no gl-errors */
	glLinkProgram(program);

	err = glGetError();
	ASSERT_GLENUMS_EQUAL(err, GL_NO_ERROR);


	/* Assert link status set to false */
	glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
	ASSERT_INTS_EQUAL(linkStatus, GL_FALSE);

	/* Verify that the info log contains a null-terminated error message */
	glGetProgramInfoLog(program, 1000, &programInfoLogLength, (char*)buffer);
	assert_fail((programInfoLogLength > 0), "CASE #5 error: info log contains no data");
	ASSERT_INTS_EQUAL((int)buffer[programInfoLogLength], (int)('\0'));


	glDetachShader(program, vs);
	glDeleteShader(vs);
	vs = 0;
	glDeleteProgram(program);
	program = 0;



	/*
	* CASE #6 - As 5, also attach a legal fragment shader and compile that too
	*/

	program = load_program("pass_two_attribs.vert", "color.frag");

	/* Attempt to link the program, this should generate no gl-errors */
	glLinkProgram(program);
	err = glGetError();
	ASSERT_GLENUMS_EQUAL(err, GL_NO_ERROR);

	/* Assert link status set to true */
	glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
	ASSERT_INTS_EQUAL(linkStatus, GL_TRUE);


}

static void test_glCompileLinkTest(suite* test_suite)
{
	GLuint program;
	GLenum err;
	GLint linkStatus=0;

	program = load_program("cube_fake.vert", "cube_sampler.frag");

	/* Attempt to link the program, this should generate no gl-errors */
	glLinkProgram(program);
	err = glGetError();
	ASSERT_GLENUMS_EQUAL(err, GL_NO_ERROR);

	/* Assert link status set to true */
	glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
	ASSERT_INTS_EQUAL(linkStatus, GL_TRUE);
}



/**
 *	Description:
 *	The only public function in the test suite is the suite factory function.
 *	This creates the suite and adds all the tests to it.
 *
 */
suite* create_suite_glLinkProgram(mempool* pool, result_set* results)
{
	suite* new_suite = create_suite(pool, "glLinkProgram", gles2_create_fixture, gles2_remove_fixture, results );

	add_test_with_flags(new_suite, "ASP12-glLinkProgram", test_glLinkProgram,
	                    FLAG_TEST_ALL | FLAG_TEST_SMOKETEST);
	add_test(new_suite, "ASP12-glCompileLinkCubeSamplerOnly", test_glCompileLinkTest);

	return new_suite;
}
