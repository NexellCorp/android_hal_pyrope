#
# This confidential and proprietary software may be used only as
# authorised by a licensing agreement from ARM Limited
# (C) COPYRIGHT 2007-2012 ARM Limited
# ALL RIGHTS RESERVED
# The entire notice above must be reproduced on all authorised
# copies and copies may only be made to the extent permitted
# by a licensing agreement from ARM Limited.
#
# -*- mode: makefile -*- 

# Build system.


#Debug printing
#Enable these to list dependents for each build rule before it is built.
#OLD_SHELL := $(SHELL)
#SHELL = $(warning [$@ depends on ($^), dependencies newer than the target: ($?)])$(OLD_SHELL)

#Debug printing of variable: Usage make print-MYVAR
print-%: ; @echo $* is $($*)


#check_cc compiler option-to-check fallback-option
check_cc = $(call check_cc2, $1 $2, $2, $3)

check_cc2 = \
	$(shell if $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; \
	then \
		echo "$(2)"; \
	else \
		echo "$(3)"; \
	fi ;)

#Remove unwanted occurrences of "./"
clean-path = $(patsubst ./%,%,$(subst /./,/,$1))

#$(call is-feature-enabled,featurename)
#returns non-empty string if enabled, empty if not
define is-feature-enabled
$(findstring -$1-,-$(VARIANT)-)
endef

# Include customer specific configuration settings
ifneq ($(CONFIG_FILE),)
	CONFIG_FILE_TO_USE=$(CONFIG_FILE)
	CONFIG_FILE_BUILD_DIR_NAME=-$(CONFIG_FILE)
else
ifeq ($(call is-feature-enabled,no_profiling),)
	CONFIG_FILE_TO_USE=default
	CONFIG_FILE_BUILD_DIR_NAME=
else
	CONFIG_FILE_TO_USE=no_profiling
	CONFIG_FILE_BUILD_DIR_NAME=
endif
endif

#get-binary-dir system
## NOTE: if this is changed. then some files must be updated in sympathy,
## so that we store in the libraries all the information required to rebuild
## the drivers in exactly the same way.
##
## These files are:
## * version_info.mak
## * internal/regression_server/testbench_build
ifeq ($(HASH_BUILD_DIR),0)
    get-binary-dir = $(BUILD_ROOT)/$(strip $1)-$(CUSTOMER)-$(HOSTLIB)-$(CONFIG)-$(TARGET_PLATFORM)-$(VARIANT)$(CONFIG_FILE_BUILD_DIR_NAME)
else
    # If md5sum doesn't exit, revert to old system
    ifeq ($(shell which md5sum 2>/dev/null),)
        get-binary-dir = $(BUILD_ROOT)/$(strip $1)-$(CUSTOMER)-$(HOSTLIB)-$(CONFIG)-$(TARGET_PLATFORM)-$(VARIANT)$(CONFIG_FILE_BUILD_DIR_NAME)
        $(warning HASH_BUILD_DIR set, but md5sum not found on PATH. Build directory will not be hashed)
    else
        # Hash the build dir, to avoid path limit problems
        # Also caches the result on first use, because TARGET/HOST_SYSTEM won't be defined until later,
        # but we don't want to $(shell ... ) every time!

        # Disable creation of the directories inside the ones we'll clean when attempting clean builds
        # Required for Cygwin Make
        ifeq ($(filter $(clean_targets),$(MAKECMDGOALS)),)
            define CACHE_BINARY_DIRS
                binary_dir_$1:=$(BUILD_ROOT)/$(shell $(BUILD_SYSTEM_DIR)/build_system_hash.sh "$(BUILD_ROOT)" "$(strip $1)-$(CUSTOMER)-$(HOSTLIB)-$(CONFIG)-$(TARGET_PLATFORM)-$(VARIANT)$(CONFIG_FILE_BUILD_DIR_NAME)")
            endef
        else
            define CACHE_BINARY_DIRS
                binary_dir_$1:=nodir_$1
            endef
        endif

        get-binary-dir = $(strip $(if $(binary_dir_$1),$(binary_dir_$1),$(eval $(call CACHE_BINARY_DIRS,$1) ) $(binary_dir_$1) ))

    endif
endif

#source-dir-to-binary-dir system, files 

#translates paths from being rooted in the source directories to being
#rooted in the binary directory for the given system. If the path
#starts with /, it is assumed to be an absolute path and isn't
#translated.
source-dir-to-binary-dir = $(call clean-path,$(addprefix $(call get-binary-dir,$1)/,$(filter-out /%,$2)) $(filter /%,$2))

target-dir-to-source-dir = $(patsubst $(call get-binary-dir, $1)/%,%,)

get-flavour-for-file = $(if $(FILE_FLAVOR-$1),$(FILE_FLAVOR-$1),$(DEFAULT_FILE_FLAVOUR))

# Translate paths from source extension to object extension, and append the file flavour before the object extension
# source-to-object-helper extension, files
source-to-object-helper = $(foreach file,$2,$(patsubst %.$1,%.$(call get-flavour-for-file,$(file))$(OBJ_EXT),$(file)))

#Translates source files to object files, taking into account both file extension change, appending file flavours and changing directory to the build output directory
#Knows about source files, static libraries and dynamic libraries.
#source-to-object system, files
source-to-object = $(call source-dir-to-binary-dir,$1,\
	$(call source-to-object-helper,S,$(filter %.S,$2)) \
	$(call source-to-object-helper,asm,$(filter %.asm,$2)) \
	$(call source-to-object-helper,c,$(filter %.c,$2)) \
	$(call source-to-object-helper,cpp,$(filter %.cpp,$2)) \
	$(call source-to-object-helper,y,$(filter %.y,$2)) \
	$(call source-to-object-helper,l,$(filter %.l,$2)) \
	$(call source-to-object-helper,rw,$(filter %.rw,$2)) \
	$(call source-to-object-helper,vertp,$(filter %.vertp,$2)) \
	$(filter %$(LIB_EXT),$2) \
	$(filter %$(DYNLIB_EXT),$2) \
	) \
	$(filter %.def,$2)

#	$if($(filter %.o,$2),$(error '$(filter %.o,$2)' - Do not pass object files to a make-X macro, pass source files instead),) \

#setup toolchains
## NOTE: if TOOLCHAINs are added, then some files must be updated in sympathy,
## so that we store in the libraries all the information required to rebuild
## the drivers in exactly the same way.
##
## These files are:
## * version_info.mak
## * internal/regression_server/testbench_build
include $(BUILD_SYSTEM_DIR)/toolchains/$(HOST_TOOLCHAIN).mak
$(eval $(call $(HOST_TOOLCHAIN)-setup,HOST))

include $(BUILD_SYSTEM_DIR)/toolchains/$(TARGET_TOOLCHAIN).mak
$(eval $(call $(TARGET_TOOLCHAIN)-setup,TARGET))

#define compilation rules for both targets, both flavours and c/c++ builds.

#$(call quiet-cmd-echo-build, command, targets)
define quiet-cmd-echo-build
	${Q}echo "  [$1]  $2"
endef

$(call get-binary-dir,$(TARGET_SYSTEM))/%.def: %.def.preproc
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CC) $(CPPFLAGS) \/EP $< > $@
	$(call $(quiet)cmd-echo-build,CC,$@)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.fast$(OBJ_EXT): %.s
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_AS) $(call TARGET_ASM_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,AS,$<)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.small$(OBJ_EXT): %.s
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_AS) $(call TARGET_ASM_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,AS,$<)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.fast$(OBJ_EXT): %.S
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CC) -c $(CPPFLAGS) -E $< > $(call get-binary-dir,$(TARGET_SYSTEM))/$*.preproc.S
	$(Q)$(TARGET_AS) $(TARGET_ASFLAGS) $(call TARGET_ASM_OUTPUTS,$@) $(call get-binary-dir,$(TARGET_SYSTEM))/$*.preproc.S
	$(call $(quiet)cmd-echo-build,AS,$<)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.small$(OBJ_EXT): %.S
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CC) -c $(CPPFLAGS) -E $< > $(call get-binary-dir,$(TARGET_SYSTEM))/$*.preproc.S
	$(Q)$(TARGET_AS) $(TARGET_ASFLAGS) $(call TARGET_ASM_OUTPUTS,$@) $(call get-binary-dir,$(TARGET_SYSTEM))/$*.preproc.S
	$(call $(quiet)cmd-echo-build,AS,$<)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.fast$(OBJ_EXT): %.c
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CC) -c $(CPPFLAGS) $(TARGET_CFLAGS) $(TARGET_FAST_FLAVOUR_FLAG) $(call TARGET_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,CC,$<)

$(call get-binary-dir,$(HOST_SYSTEM))/%.fast$(OBJ_EXT): %.c
	@mkdir -p $(dir $@)
	$(Q)$(HOST_CC) -c $(CPPFLAGS) $(HOST_CFLAGS) $(HOST_FAST_FLAVOUR_FLAG) $(call HOST_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,HOSTCC,$<)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.small$(OBJ_EXT): %.c
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CC) -c $(CPPFLAGS) $(TARGET_CFLAGS) $(TARGET_SMALL_FLAVOUR_FLAG) $(call TARGET_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,CC,$<)

$(call get-binary-dir,$(HOST_SYSTEM))/%.small$(OBJ_EXT): %.c
	@mkdir -p $(dir $@)
	$(Q)$(HOST_CC) -c $(CPPFLAGS) $(HOST_CFLAGS) $(HOST_SMALL_FLAVOUR_FLAG) $(call HOST_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,HOSTCC,$<)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.fast$(OBJ_EXT): %.cpp
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CXX) -c $(CPPFLAGS) $(TARGET_CXXFLAGS) $(TARGET_FAST_FLAVOUR_FLAG) $(call TARGET_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,CC,$<)

$(call get-binary-dir,$(HOST_SYSTEM))/%.fast$(OBJ_EXT): %.cpp
	@mkdir -p $(dir $@)
	$(Q)$(HOST_CXX) -c $(CPPFLAGS) $(HOST_CXXFLAGS) $(HOST_FAST_FLAVOUR_FLAG) $(call HOST_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,HOSTCC,$<)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.small$(OBJ_EXT): %.cpp
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CXX) -c $(CPPFLAGS) $(TARGET_CXXFLAGS) $(TARGET_SMALL_FLAVOUR_FLAG) $(call TARGET_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,CC,$<)

$(call get-binary-dir,$(HOST_SYSTEM))/%.small$(OBJ_EXT): %.cpp
	@mkdir -p $(dir $@)
	$(Q)$(HOST_CXX) -c $(CPPFLAGS) $(HOST_CXXFLAGS) $(HOST_SMALL_FLAVOUR_FLAG) $(call HOST_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,HOSTCC,$<)

#also support C files placed in the binary directories somewhat 
$(call get-binary-dir,$(TARGET_SYSTEM))/%.fast$(OBJ_EXT): $(call get-binary-dir,$(TARGET_SYSTEM))/%.c
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CC) -c $(CPPFLAGS) $(TARGET_CFLAGS) $(TARGET_FAST_FLAVOUR_FLAG) $(call TARGET_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,CC,$<)

$(call get-binary-dir,$(HOST_SYSTEM))/%.fast$(OBJ_EXT): $(call get-binary-dir,$(HOST_SYSTEM))/%.c
	@mkdir -p $(dir $@)
	$(Q)$(HOST_CC) -c $(CPPFLAGS) $(HOST_CFLAGS) $(HOST_FAST_FLAVOUR_FLAG) $(call HOST_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,HOSTCC,$<)

$(call get-binary-dir,$(TARGET_SYSTEM))/%.small$(OBJ_EXT): $(call get-binary-dir,$(TARGET_SYSTEM))/%.c
	@mkdir -p $(dir $@)
	$(Q)$(TARGET_CC) -c $(CPPFLAGS) $(TARGET_CFLAGS) $(TARGET_SMALL_FLAVOUR_FLAG) $(call TARGET_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,CC,$<)

$(call get-binary-dir,$(HOST_SYSTEM))/%.small$(OBJ_EXT): $(call get-binary-dir,$(HOST_SYSTEM))/%.c
	@mkdir -p $(dir $@)
	$(Q)$(HOST_CC) -c $(CPPFLAGS) $(HOST_CFLAGS) $(HOST_SMALL_FLAVOUR_FLAG) $(call HOST_COMPILER_OUTPUTS,$@) $<
	$(call $(quiet)cmd-echo-build,HOSTCC,$<)

#set up dependency generation rules

# The following makedep deals with dependecies generate by gcc -MM
#define makedep
#	@mkdir -p $(dir $@)
#	@$(SHELL) -ec '$1 $(CPPFLAGS) $< \
#		| sed '\''s,$(basename $(notdir $<))\.o[ :]*,$(basename $@).d $(basename $@).small$(OBJ_EXT) $(basename $@).fast$(OBJ_EXT) : ,;s,\b\([A-Za-z]\):\/,\/cygdrive/\1\/,g'\'' > $@; \
#		[ -s $@ ] || rm -f $@' # 2>/dev/null
#endef

# The following makedep deals with dependecies generate by armcc -mm 
#define makedep_armcc
#	@mkdir -p $(dir $@)
#	@$(SHELL) -ec '$1 $(CPPFLAGS) $< \
#		| sed '\''1s,target[:],$(basename $@).d $(basename $@).small$(OBJ_EXT) $(basename $@).fast$(OBJ_EXT) :,;s,target[:],,;s,[ \t]*$$, \\,;$$s,\\,,;s,\b\([A-Za-z]\):\/,\/cygdrive/\1\/,g'\'' > $@; \
#		[ -s $@ ] || rm -f $@' # 2>/dev/null
#endef

# The following makedep deals with dependecies generate by gcc and armcc 
define makedep
	@mkdir -p $(dir $@)
	$(Q)$(SHELL) -ec '$1 $(CPPFLAGS) $< \
		| sed '\''s,$(basename $(notdir $<))\.o[ :]*,$(basename $@).d $(basename $@).small$(OBJ_EXT) $(basename $@).fast$(OBJ_EXT) : ,;s, \\*$$,,;1s,target[:],$(basename $@).d $(basename $@).small$(OBJ_EXT) $(basename $@).fast$(OBJ_EXT) :,;s,target[:],,;s,[ \t]*$$, \\,;$$s,\\,,;s,\b\([A-Za-z]\):\/,\/cygdrive/\1\/,g'\'' > $@; \
		[ -s $@ ] || rm -f $@' # 2>/dev/null
endef

ifeq ($(DONT_GENERATE_HEADERDEPS),)
$(call get-binary-dir,$(TARGET_SYSTEM))/%.d: %.c
	$(call makedep,$(TARGET_DEP_CC))

$(call get-binary-dir,$(HOST_SYSTEM))/%.d: %.c
	$(call makedep,$(HOST_DEP_CC))

$(call get-binary-dir,$(TARGET_SYSTEM))/%.d: %.cpp
	$(call makedep,$(TARGET_DEP_CXX))

$(call get-binary-dir,$(HOST_SYSTEM))/%.d: %.cpp
	$(call makedep,$(HOST_DEP_CXX))
endif

#These are for access to build paths from outside scripts
.PHONY: get-target-product-dir get-host-product-dir
get-target-product-dir:
	@echo $(call get-binary-dir,$(TARGET_SYSTEM))

get-host-product-dir:
	@echo $(call get-binary-dir,$(HOST_SYSTEM))

#These translate source paths to object paths, but call the toolchain specific hooks for translating dynamic library dependencies, and are therefore useful in the bodies of build rules.

# NOTE: Modification for msvc-ce6 toolchain to allow .def files
# To do this properly will require major changes in Makefile.rules
source-to-object-target-fix-libs = $(filter-out %$(DYNLIB_EXT) %.def,$(call source-to-object,$(TARGET_SYSTEM),$1)) \
	$(call TARGET_REWRITE_LIBRARY_COMMANDLINE,$(TARGET_SYSTEM),$(filter %$(DYNLIB_EXT),$(call source-to-object,$(TARGET_SYSTEM),$1))) \
	$(patsubst %.def,-def:%.def,$(filter %.def,$1))

source-to-object-host-fix-libs = $(filter-out %$(DYNLIB_EXT),$(call source-to-object,$(HOST_SYSTEM),$1)) \
	$(call HOST_REWRITE_LIBRARY_COMMANDLINE,$(HOST_SYSTEM),$(filter %$(DYNLIB_EXT),$(call source-to-object,$(HOST_SYSTEM),$1)))

process-linker-flags = $(subst MULTITHREADED,$($1_MULTITHREADED_LDFLAGS),$(subst CXX,$($1_CXX_LDFLAGS),$2))

ifneq ($(call is-feature-enabled,android),)
define make-target-binary 
$(call source-dir-to-binary-dir,$(TARGET_SYSTEM),$1): Android.mk egl.cfg;
	$(call make-target-android, $1, $2, $3,BUILD_EXECUTABLE)
endef
else
# $(call make-binary, unprefixed-binary-name, source-file-list)
define make-target-binary
$(call source-dir-to-binary-dir,$(TARGET_SYSTEM),$1): $(call source-to-object,$(TARGET_SYSTEM),$2) $(eval TARGET_DEP_SRCS += $2) ;
	$(Q)$$(call TARGET_TRANSLATE_PATHS,$$(TARGET_LD) $$(TARGET_LDFLAGS) $$(call TARGET_LINKER_OUTPUTS,$$@) $$(call source-to-object-target-fix-libs,$2) $$(call process-linker-flags,TARGET,$3) $$(TARGET_LIBS))
	$(call $(quiet)cmd-echo-build,LD,$$@)
	$(Q)$$(call TARGET_TRANSLATE_PATHS,$$(TARGET_EDITBIN) $(call TARGET_TRANSLATE_FILEPATH,$(call source-dir-to-binary-dir,$(TARGET_SYSTEM),$1)))
endef
endif

ANDROIDMK_DOLLAR := $$$$
define make-target-android
	$(Q)echo "# $(notdir $1)" > Android.mk.$(notdir $1)
	$(Q)echo "include $(ANDROIDMK_DOLLAR)""(CLEAR_VARS)" >> Android.mk.$(notdir $1)
	$(Q)echo "LOCAL_MODULE:=$(notdir $1)" >> Android.mk.$(notdir $1)
	$(Q)echo "LOCAL_PRELINK_MODULE:=false" >> Android.mk.$(notdir $1)
	$(Q)echo "LOCAL_MODULE_TAGS:=eng" >> Android.mk.$(notdir $1)
	$(Q)echo "LOCAL_C_INCLUDES:=$(ANDROIDMK_DOLLAR)""(MALI_SEARCH_PATH)" >> Android.mk.$(notdir $1)
	$(Q)echo "LOCAL_CFLAGS:=$(ANDROIDMK_DOLLAR)""(MALI_DEFINES)">> Android.mk.$(notdir $1)
	$(Q)echo "LOCAL_SRC_FILES:=$(filter %.c %.cpp, $2)" >> Android.mk.$(notdir $1)
	$(Q)echo "LOCAL_SHARED_LIBRARIES:=$(notdir $(patsubst %.so, %, $(filter %.so, $2)))" >> Android.mk.$(notdir $1)
	$(Q)echo "LOCAL_STATIC_LIBRARIES:=$(notdir $(patsubst %.a, %, $(filter %.a, $2)))">> Android.mk.$(notdir $1)
	$(Q)echo "include $(ANDROIDMK_DOLLAR)""($4)" >> Android.mk.$(notdir $1)
	$(Q)echo "" >> Android.mk.$(notdir $1)
	$(Q)cat Android.mk.$(notdir $1) >> Android.mk
	$(Q)rm Android.mk.$(notdir $1)
endef	

define make-host-binary
$(call source-dir-to-binary-dir,$(HOST_SYSTEM),$1): $(call source-to-object,$(HOST_SYSTEM),$2) $(eval HOST_DEP_SRCS += $2) ;
	$(Q)$$(call HOST_TRANSLATE_PATHS,$$(HOST_LD) $$(HOST_LDFLAGS) $$(call HOST_LINKER_OUTPUTS,$$@) $$(call source-to-object-host-fix-libs,$2) $$(call process-linker-flags,HOST,$3) $$(HOST_LIBS))
	$(call $(quiet)cmd-echo-build,HOSTLD,$$@)
endef

#$(call make-target-static-library output-name, source-file-list-and-library-list, extra-options)
define make-target-static-library
$(call source-dir-to-binary-dir,$(TARGET_SYSTEM),$1): $(call source-to-object,$(TARGET_SYSTEM),$2) $(eval TARGET_DEP_SRCS += $2) ;
	$(Q)$$(call TARGET_TRANSLATE_PATHS,$$(TARGET_AR) $$(TARGET_ARFLAGS) $$(call TARGET_AR_OUTPUTS,$$@) $$(call source-to-object-target-fix-libs,$2) $$(call process-linker-flags,TARGET,$3))
	$(call $(quiet)cmd-echo-build,AR,$$@)
endef

define make-host-static-library
$(call source-dir-to-binary-dir,$(HOST_SYSTEM),$1): $(call source-to-object,$(HOST_SYSTEM),$2) $(eval HOST_DEP_SRCS += $2) ;
	$(Q)$$(call HOST_TRANSLATE_PATHS,$$(HOST_AR) $$(HOST_ARFLAGS) $$(call HOST_AR_OUTPUTS,$$@) $$(call source-to-object-host-fix-libs,$2) $$(call process-linker-flags,HOST,$3))
	$(call $(quiet)cmd-echo-build,HOSTAR,$$@)
endef

#$(call make-target-dynamic-library output-name, source-file-list-and-library-list, extra-options)
define make-target-dynamic-library
$(call source-dir-to-binary-dir,$(TARGET_SYSTEM),$1): $(call source-to-object,$(TARGET_SYSTEM),$2) $(eval TARGET_DEP_SRCS += $2) ;
	$(Q)$$(call TARGET_TRANSLATE_PATHS,$$(TARGET_DYNLIB) $$(TARGET_DYNLIBFLAGS) $$(call TARGET_DYNLIB_OUTPUTS,$$@) $$(call source-to-object-target-fix-libs,$2) $$(call process-linker-flags,TARGET,$3) $$(TARGET_DYNLIBS))
	$(call $(quiet)cmd-echo-build,LD,$$@)
	$(Q)$$(call TARGET_TRANSLATE_PATHS,$$(TARGET_EDITBIN) $(call TARGET_TRANSLATE_FILEPATH,$1))
endef

define make-host-dynamic-library
$(call source-dir-to-binary-dir,$(HOST_SYSTEM),$1): $(call source-to-object,$(HOST_SYSTEM),$2) $(eval HOST_DEP_SRCS += $2) ;
	$(Q)$$(call HOST_TRANSLATE_PATHS,$$(HOST_DYNLIB) $$(HOST_DYNLIBFLAGS) $$(call HOST_DYNLIB_OUTPUTS,$$@) $$(call source-to-object-host-fix-libs,$2) $$(call process-linker-flags,HOST,$3))
	$(call $(quiet)cmd-echo-build,HOSTLD,$$@)
endef

#define useful frontends that define binaries for both builds. If both systems are the same, don't define the rules twice.
#The evals and ;s are needed to satisfy quirks in the make parser.
ifneq ($(HOST_SYSTEM),$(TARGET_SYSTEM))
define make-binary
$(eval $(call make-target-binary,$1,$2,$3)) ;
$(eval $(call make-host-binary,$1,$2,$3)) ;
endef

define make-dynamic-library
$(eval $(call make-target-dynamic-library,$1,$2,$3)) ;
$(eval $(call make-host-dynamic-library,$1,$2,$3)) ;
endef

define make-static-library
$(eval $(call make-target-static-library,$1,$2,$3)) ;
$(eval $(call make-host-static-library,$1,$2,$3)) ;
endef


else


define make-binary
$(eval $(call make-target-binary,$1,$2,$3)) ;
endef

define make-dynamic-library
$(eval $(call make-target-dynamic-library,$1,$2,$3)) ;
endef

define make-static-library
$(eval $(call make-target-static-library,$1,$2,$3)) ;
endef

endif

# Make a single library Aliases
# $(call library-alias-rule, newalias, original)
define library-alias-rule
# Work step:
$(1): $(2)
	$(Q)ln -sf $$(<F) $$(@)
	$(call $(quiet)cmd-echo-build,SYMLINK,$$(@F) -> $$(@))
endef

# $(call make-library-aliases, Target alias1 alias2 ... alias{n} )
# Sets up rules to create symlinks:
# alias{n} -> $(notdir alias{n-1})
# ...
# alias2 -> $(notdir alias1)
# alias1 -> $(notdir Target)cd bui	
define make-library-aliases
# Recursive step:
# If two words are present, we recurse and do work. Otherwise, do nothing at all
$(eval \
$(if $(wordlist 2, $(words $(1)), $(1)), \
$(call make-library-aliases,$(wordlist 2, $(words $(1)), $(1)) ) \
$(eval $(call library-alias-rule,$(word 2, $(1)),$(firstword $(1)))) \
 ))
endef

#$(call set-file-flavour,flavor,list-of-files)
define set-file-flavour
	$(foreach file,$2,$(eval FILE_FLAVOR-$(file) := $(1)))
endef

CLEAN_FILES += $(BUILD_ROOT)

clean:
	$(Q)-rm -rf $(CLEAN_FILES)
	$(call $(quiet)cmd-echo-build,CLEAR,$(CLEAN_FILES))
